---
title: "Untitled"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, root.dir = "./")
```

## R Markdown

```{r}
# packages <- c("ape", "car", "fossil", "gstat", "piecewiseSEM",
#               "rgdal", "raster", "segmented", "sp", "XML", "plyr", "pbapply", "readxl",
#               "jtools", "visreg", "e1071", "plot3D", "viridis", "interactions", "splancs")
# install.packages(packages, dependencies = TRUE)
```
Next, load packages into workspace.
```{r}
library(gstat)
library(rgdal)
library(raster)
library(ape)
library(car)
library(fossil)
library(piecewiseSEM)
library(segmented)
library(sp)
library(XML)
library(plyr)
library(pbapply)
library(readxl)
library(jtools)
library(visreg)
library(e1071)
library(plot3D)
library(viridis)
library(interactions)
```

```{r}
URL <- "http://biogeo.ucdavis.edu/data/climate/worldclim/1_4/grid/cur/bio_10m_bil.zip"
wd <- getwd()
td <- tempdir()
setwd(td)
temp <- tempfile(fileext = ".zip")
download.file(URL, temp)
unzip(temp)
tempRast <- raster("bio1.bil")/10
precipRast <- raster("bio12.bil")/1
unlink(dir(td))
setwd(wd)
```

```{r}
# Calculate NPP using the Miami model.
npp.mia.t <- 3000/(1+exp(1.315-0.119*tempRast))
npp.mia.p <- 3000*(1-exp(-0.000664*precipRast))
nppRast<-min(stack(npp.mia.t,npp.mia.p))
plot(nppRast, main="NPP", col=viridis(100))
```

```{r}
# Alternately, if the Dataset S2 is in the working directory, it can be loaded using
# following code (remove hash mark):
# nppRast <- raster("Tallavaara_Dataset_1.tif")
```

### Biodiversity
Biodiversity variable is based on global mammal, bird, and vascular plant richness data. We scaled these
richness values to vary between 0 an 1 and finally averaged them to form a single biodiversity variable.

#### Mammal and bird richness
We downloaded mammal and bird richness data from Biodiversitymapping.org (http://biodiversitymapping.
org/wordpress/index.php/home/).
```{r}
URL <- paste("http://biodiversitymapping.org/","wordpress/wp-content/uploads/2016/11/",
"biodiversitymapping_TIFFs_20Dec2016.zip", sep="") # Use paste just to avoid problems
URL <- paste("https://biodiversitymapping.org", "wp-content/uploads/2020/02",
             "BiodiversityMapping_TIFFs_2019_03d14_revised.zip", sep="/")
# to RMarkdown output caused by
# long strings
wd <- getwd()
td <- tempdir()
setwd(td)
temp <- tempfile(fileext = ".zip")
download.file(URL, temp)
unzip(temp)
birDRast <- raster("BiodiversityMapping_TIFFs_2019_03d14/Birds/Richness_10km_Birds_v7_EckertIV_no_seabirds.tif")
mamDRast <- raster("BiodiversityMapping_TIFFs_2019_03d14/Mammals/Richness_10km_MAMMALS_mar2018_EckertIV.tif")
unlink(dir(td))
setwd(wd)
# Use the projection of the NPP raster as a template projection for mammal and bird
# diversity rasters, combine them into 'animal' diversity, and scale animal diversity
# to vary between 0 to 1.
birDRast<-projectRaster(birDRast, nppRast)
mamDRast<-projectRaster(mamDRast, nppRast)
animDRast <- birDRast + mamDRast
animDRast.scal <- animDRast/cellStats(animDRast,'max')
```
#### Plant richness
Our plant richness data are based on Kreft and Jetz (2007) and are part of the Ellis et al. (2012) data
(native plant richness ‘N’). The data can be downloaded from ecotope.org (http://ecotope.org/anthromes/
biodiversity/plants/data/). We interpolated these global data over the same global grid as NPP and animal
diversity (see above) using inverse distance weighting (IDW) interpolation. Below, we will also eveluate the
interpolation by comparing interpolated richness to original (model-based) richness data.
```{r}
URL <- "http://ecotope.org/files/ellis_2012/ellis_2012_shapefile.zip"
wd <- getwd()
td <- tempdir()
setwd(td)
temp <- tempfile(fileext = ".zip")
download.file(URL, temp)
unzip(temp)
dsn <- dir(tempdir(), "*.shp$")
layer <- sub(".shp$", "", dsn)
plants <- readOGR(dsn=dsn, layer=layer)
unlink(dir(td))
setwd(wd)
# Transform Spatial Polygons Data into a normal data frame, subset, and transform it into
# a Spatial Points Data Frame and change projection to the global Mercator projection.
plants <- as.data.frame(plants)
plants <- data.frame(plants$X, plants$Y, plants$N)
names(plants) <- c("x","y","N")
plants2 <- plants # This data will be used later, when comparing interpolation
# to original data
coordinates(plants) <- ~x+y
proj4string(plants) = CRS("+proj=longlat +datum=WGS84")
plantsM <- spTransform(plants, CRS("+init=epsg:3395"))
# Create a global grid with the same extent and resolution as NPP raster and change the
# projection of global grid to the global Mercator projection. This grid is used when
# interpolating the plant richness data to cover the same area as other environmental
# variables.
globalGrid <- as.data.frame(expand.grid(x=seq(-180,180, by=0.1666667),
y=seq(-80,84, by=0.1666667)))
coordinates(globalGrid) <- ~x+y
proj4string(globalGrid) = CRS("+proj=longlat +datum=WGS84")
globalGridM <- spTransform(globalGrid, CRS("+init=epsg:3395"))
# IDW-interpolation to the plant richness data using krige-function (without any model)
# of the gstat package
plantsIDW <- krige(N ~ 1, plantsM, globalGridM, NULL, nmax=10)
# Change projection of the interpolated data to lon-lat, make a raster out of the data
# with NPP raster as a template, and scale the plant diversity.
plantsIDWLL <- spTransform(plantsIDW, CRS("+proj=longlat +datum=WGS84"))
plantsDataIDW <- as.data.frame(plantsIDWLL)
plantsDataIDW <- data.frame(plantsDataIDW$x, plantsDataIDW$y, plantsDataIDW$var1.pred)
plantDRast <- rasterFromXYZ(plantsDataIDW)
crs(plantDRast) <- "+proj=longlat +datum=WGS84"
plantDRast<-projectRaster(plantDRast, nppRast)
plantDRast<-mask(plantDRast, nppRast)
plantDRast.scal <- plantDRast/cellStats(plantDRast,'max')
```
Comparison of the interpolated richness to the original model-based richness
```{r}
# Extract interpolated values for original data points
pointsRast <- extract(plantDRast, cbind(plants2$x,plants2$y))
plants2$rastpoints <- pointsRast # add to the data
# Diff. between interpolated and original richness
plants2$diffs <- plants2$rastpoints-plants2$N
# Plot
par(mfrow=c(1,2), mar=c(4,4,1,1))
plot(plants2$N,plants2$rastpoints, las=1, pch=0, ylab="Interpolated",
xlab="Modeled")
abline(0,1, col="red", lwd=2)
plot(plants2$N,plants2$diffs, yaxt="n", ylim=c(-300,300), pch=0, xlab="Modeled",
ylab="Interpolated-Modeled")
axis(side=2, at=c(-300,-200,-100,0,100,200,300), las=2)
abline(h=0, col="red", lwd=2)
```

### Combined diversity
To form the final biodiversity variable, we averaged scaled animal (mammal and bird richness) and plant
richness values.
```{r}
bioDRast <- (animDRast.scal + plantDRast.scal)/2
plot(bioDRast, main="Biodiversity (combined plant, mammal, and bird richness)", col=viridis(100))
```
```{r}
# Alternately, if the Dataset S3 is in the working directory, it can be loaded using
# following code (remove hash mark):
# bioDRast <- raster("Tallavaara_Dataset_2.tif")
```
### Pathogen stress
We extracted the pathogen data from Standard Cross-Cultural Sample (SCCS). The pathogen data are based
on Cashdan (2014) and Low (1994). We interpolated the point data over the same global grid as other
environmental variables using kriging interpolation with exponential variogram model in `gstat` package. We
downloaded the pathogen data from the E. Anthon Eff’s webpage (http://capone.mtsu.edu/eaeff/DEf_SCCS.
html). See also WorldCultures.org (http://www.worldcultures.org/) for the official site of the SCCS data.
Following code loads the SCCS data and extracts variables needed for analysis. Variable v2178 is the z-score
variable of 10 pathogen prevalence values, which we use as the pathogen stress variable in our analyses. We
added five pseudo data points in the western polar region and northern central Asia. These areas lack data
in SCCS data. Western polar region z-score value of -0.96 is based on the mean of arctic and subarctic values
in North America. Central Asian value of -0.77 is the mean of four northern Eurasian values (Saami (Lapps),
Samoyed, Yukaghir, and Chukchee).Below, we will also evaluate interpolation of pathogen data by comparing
interpolated and original pathogen stress values.
```{r}
# Download the data.
load(url("http://capone.mtsu.edu/eaeff/downloads/DEf01f.Rdata"))
pathogens1 <- SCCS[,c("ord", "socname", "long", "lati")]
pathogens2 <- SCCS[,c("v2178")]
pathogens <- as.data.frame(cbind(pathogens1,pathogens2))
names(pathogens) <- c("ord", "socname", "lon", "lat", "pathoscore10")
# Add pseudo data points
patho1 <- c(187, "pseudo1", -43.386172, 60.147033, -0.96)
patho2 <- c(188, "pseudo2", -23.163979, 70.899655, -0.96)
patho3 <- c(189, "pseudo3", -33.707298, 82.355691, -0.96)
patho4 <- c(192, "pseudo6", -86.851987, 81.298900, -0.96)
patho5 <- c(194, "pseudo8", 101.504786, 65.214012, -0.77)
pathogens <- as.data.frame(rbind(pathogens, patho1, patho2, patho3, patho4, patho5))
pathogens$lon <- as.numeric(pathogens$lon)
pathogens$lat <- as.numeric(pathogens$lat)
pathogens$pathoscore10 <- as.numeric(pathogens$pathoscore10)
pathogens2 <- pathogens # This data will be used later to evaluate the interpolation.
# Interpolate these data over global grid (see above) using kriging interpolation.
# Switch projection to global Mercator
coordinates(pathogens) <- ~lon+lat
proj4string(pathogens) = CRS("+proj=longlat +datum=WGS84")
pathogensM <- spTransform(pathogens, CRS("+init=epsg:3395"))
# Calculate empirical semi variogram
pathoSemivgm<-variogram(pathoscore10~1, locations=pathogensM, data=pathogensM)
pathoSemivgm
# Based on its values, define range, nugget and partial sill
range <- 14905075/3 # 1/3*largest distance
nugget <- (0.08281362 + 0.15023716 + 0.17855292)/3 # average of the first three
# semivariogram values
psill <- (0.41257526 + 0.41962169 + 0.43027830 # average of the last five values
          + 0.48063340 + 0.49545721)/5
# Model variogram with exponential model
pathoModVgm <- vgm(psill=psill, model="Exp", nugget=nugget, range=range)
pathoFitVgm <- fit.variogram(pathoSemivgm, pathoModVgm)
plot(pathoSemivgm, pathoFitVgm, main="Empirical and model variogram", cex.main=0.8)
```
```{r}
# Finally, kriging interpolation itself.
pathoKrig<-krige(formula=pathoscore10 ~ 1, locations=pathogensM, newdata=globalGridM,
model=pathoModVgm)
## [using ordinary kriging]
# Switch the projection of the interpolated data back to lon-lat.
pathoKrigedLL <- spTransform(pathoKrig, CRS("+proj=longlat +datum=WGS84"))
# Transform spatial data to 'normal' data frame.
pathoData <- as.data.frame(pathoKrigedLL)
pathoData <- data.frame(pathoKrigedLL$x, pathoKrigedLL$y, pathoKrigedLL$var1.pred)
# Create a raster.
pathoRast <- rasterFromXYZ(pathoData)
crs(pathoRast) <- "+proj=longlat +datum=WGS84"
# Use NPP raster as a template.
pathoRast<-projectRaster(pathoRast, nppRast)
pathoRast<-mask(pathoRast, nppRast)
# Plot results.
plot(pathoRast, main="Pathogen stress", col=viridis(100))
```
Comparison of the interpolated richness to the original model-based richness:
```{r}
pointsRastPatho <- extract(pathoRast,cbind(pathogens2$lon,pathogens2$lat))
pathogens2$rastpoints <- pointsRastPatho
pathogens2$diffs <- pathogens2$rastpoints-pathogens2$pathoscore10
par(mfrow=c(1,2), mar=c(4,4,1,1))
plot(pathogens2$pathoscore10, pathogens2$rastpoints,las=1, pch=0,
xlim=c(-1,1.5), ylim=c(-1,1.5), xlab="Observed", ylab="Interpolated")
abline(0,1, col="red", lwd=2)
plot(pathogens2$pathoscore10, pathogens2$diffs, yaxt="n", xlim=c(-1,1.5), pch=0,
xlab="observed", ylab="Interpolated-Observed")
axis(side=2, at=c(-0.6,-0.4,-0.2,0,0.2, 0.4, 0.6), las=2)
abline(h=0, col="red", lwd=2)
```
```{r}
# Alternately, if the Dataset S4 is in the working directory, it can be loaded using
# following code (remove hash mark):
# pathoRast <- raster("Tallavaara_Dataset_3.tif")
```
## Response variable
### Hunter-gatherer population density
Our hunter-gatherer population density data is a combination of the datasets of Binford (2001) and Kelly
(2013). If population is present in both sets, we used the **weighted geometric mean of the two sources**
(Tallavaara used the unweighted arithmetic mean) for a given group. The weight for a density given by Kelly
(2013) is triple the weight for a density given by Binford (2001), due to some specific distrust in
Binford's quantitative skill (cf. eg.
https://www.reddit.com/r/AskAnthropology/comments/fyma6z/what_is_a_good_source_to_estimate_nonagriculture/fn2y81d 
but also elsewhere)
in addition to the relative age of that reference. In cases
where hunter-gatherer population is present only one of the datasets, we used the value given by that dataset.
This (partly) combined variable is `densityC`. We used natural logarithm of population density (`ldensityC`)
in our analyses.
```{r}
# Load hunter-gatherer dataset (assumes that it is in the working directory).
# Use readxl package to read xls-file
hgdata <- read_excel("Tallavaara_Dataset_4.xls")
hgdata$densityB <- as.numeric(hgdata$densityB)
hgdata$densityK <- as.numeric(hgdata$densityK)
hgdata$densityC <- as.numeric(hgdata$densityC)

hgdata[337,]
```
The relationship between Binford’s and Kelly’s data:
```{r}
par(mar=c(4,4,1,1))
plot(hgdata$densityK, hgdata$densityB, ylim=c(0,450), xlim=c(0,450), las=1, pch=0,
xlab="Kelly data", ylab="Binford data")
abline(0,1, col="red", lwd=2)
abline(lm(densityB~densityK, data=hgdata), lty=2)
```
```{r}
# Add ln(population density) to the data.
hgdata$ldensityC <- log(hgdata$densityC)
# Remove suspicious "non-normal" hunter-gatherer cases.
hgdata <- hgdata[hgdata$subpop == "n",]
# Plot the distribution of hunter-gatherer population density.
par(mar=c(4,4,3,1))
hist(
  hgdata$densityC,
  main="Distribution of hunter-gatherer/n population density",
  nclass=31,
  xlab="Population density (#/100km2)", col="darkgrey", cex.main=0.8)
```
```{r}
# Remove clear outliers
hgdata <- hgdata[hgdata$densityC < 300,]
# Extract coordinates from the data
coords <- hgdata[,c("longitude","latitude")]
```
## Combined data of population density and environmental predictors.
Here, we first extract values of the three environmental variables for locations of hunter-gatherer groups
in the ethnographic data.Then, we combine population density with environmental variables to form the
primary dataset used in the analyses.
```{r}
# Make a raster stack of environmental variables
predictors <- stack(nppRast, bioDRast, pathoRast)
# Extract environmental information for hunter-gatherer populations
predictordata <- as.data.frame(extract(predictors,coords,layer=1,nl=3))
names(predictordata) <- c("npp", "biodiv", "pathos")
# Combine hunter-gatherer and environmental data
data <- cbind(hgdata, predictordata)
data[279,] # Check that biodiv is not NaN
```
# Statistical analyses
This section covers all the statistical analyses of the data constructed above. In addition, this section contains
global projections of hunter-gatherer population density and the analyses of these global data.
## Breakpoint analysis
Because visual inspection suggested changes in linear trends between NPP and population density and
pathogen stress, we fitted piecewise regression models using segmented package. It estimates potential
breakpoints and tests if the effects are indeed different before and after the estimated breakpoints. We
divided our data into low and high productivity environments based on the threshold in NPP identified by
the breakpoint analysis.
# First, between npp and population density
```{r}
fit1 <- lm(ldensityC ~ npp, data=data)
set.seed(1234)
fit1.s <- segmented(fit1, seg.Z=~npp,
control=seg.control(n.boot=1000, stop.if.error=T, it.max=1000))
summary(fit1.s)
```
```{r}
davies.test(fit1,~npp,k=10)
```
```{r}
# Next, between npp and pathogenic stress
fit2 <- lm(pathos ~ npp, data=data)
set.seed(1234)
fit2.s <- segmented(fit2, seg.Z=~npp,
control=seg.control(n.boot=1000,stop.if.error=T,it.max=1000))
summary(fit2.s)
```
```{r}
davies.test(fit2, ~npp, k=5)
```
```{r}
nppThresh <- (fit1.s$psi[2] + fit2.s$psi[2]) / 2
data$nrg <- ifelse(data$npp > nppThresh,
                   c("hi"), c("lo"))
data$nrg <- as.factor(data$nrg)
# Plot the figure
par(mar = c(3, 5, 0, 5))
par(fig = c(0, 1, 0.45, 1))
symbols(
  data$npp,
  data$ldensityC,
  circle = sqrt((data$pathos + sqrt(min(
    data$pathos
  ) ^ 2) + 0.03) / pi),
  inches = 0.25,
  xlab = "",
  fg = "black",
  bg = "#ADD8E666",
  axes = F,
  ylab = "",
  xlim = c(0, max(data$npp) + 100),
  ylim = c(min(data$ldensityC), max(data$ldensityC + 0.5))
)
axis(
  side = 2,
  at = c(-1, 0, 1, 2, 3, 4, 5),
  las = 2,
  tck = -0.02
)
mtext("ln(Pop. density)", side = 2, line = 2)
plot(
  fit1.s,
  add = T,
  rug = F,
  lwd = 4,
  col = "black"
)
lines(fit1.s)
#radius <- sqrt((data$pathos+sqrt(min(data$pathos)^2))/pi)
#ylim <- c(min(data$ldensityC),max(data$ldensityC+0.5))
#legPop <- c(0.03, median(data$pathos+sqrt(min(data$pathos)^2)+0.03),
# max(data$pathos+sqrt(min(data$pathos)^2)+0.03))
#legRad <- sqrt( legPop / pi )
#hin <- par('pin')[2]
#burgPerInch <- (ylim[2]-ylim[1]) / hin
#radPerInch <- max(radius)/0.25
#heightAdj <- legRad/radPerInch*burgPerInch
#symbols( rep(2000,3), rep(-1,3), circles = legRad, inches = 0.25, add = TRUE)
par(fig = c(0, 1, 0.0, 0.55), new = TRUE)
symbols(
  data$npp,
  data$pathos,
  circle = sqrt((data$ldensityC + abs(
    min(data$ldensityC)
  ) + 0.1) / pi),
  inches = 0.25,
  xlab = "NPP",
  fg = "black",
  bg = "#FFC0CB99",
  axes = F,
  ylab = "",
  xlim = c(0, max(data$npp) + 100),
  ylim = c(min(data$pathos) - 0.05, max(data$pathos) + 0.1)
)
axis(
  side = 4,
  at = c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75),
  lab = c(-1, "", -0.5, "", 0, "", 0.5, ""),
  las = 2,
  tck = -0.02
)
mtext("Pathogen stress", side = 4, line = 3)
axis(side = 1, tck = -0.02)
plot(
  fit2.s,
  add = T,
  rug = F,
  lwd = 4,
  col = "black"
)
lines(fit2.s)
#radius <- sqrt((data$ldensityC + abs(min(data$ldensityC)) + 0.1)/pi)
#ylim <- c(min(data$pathos)-0.1,max(data$pathos)+0.1)
#legPop <- c(min(data$ldensityC + abs(min(data$ldensityC)) + 0.1),
#median(data$ldensityC + abs(min(data$ldensityC)) + 0.1),
#max(data$ldensityC + abs(min(data$ldensityC)) + 0.1))
#legRad <- sqrt( legPop / pi )
#hin <- par('pin')[2]
#burgPerInch <- (ylim[2]-ylim[1]) / hin
#radPerInch <- max(radius)/0.25
#heightAdj <- legRad/radPerInch*burgPerInch
#symbols( rep(2000,3), rep(-0.8,3), circles = legRad, inches = 0.25, add = TRUE)
```
We also calculated R² values for models, where NPP explains population density and pathogen stress in low
and high productivity.
```{r}
npp.dens.low <- lm(ldensityC ~ npp, data=data[data$nrg=="lo",])
npp.dens.high <- lm(ldensityC ~ npp, data=data[data$nrg=="hi",])

npp.patho.low <- lm(pathos ~ npp, data=data[data$nrg=="lo",])
npp.patho.high <- lm(pathos ~ npp, data=data[data$nrg=="hi",])
summary(npp.dens.low)$adj.r.squared
```
```{r}
summary(npp.dens.high)$adj.r.squared
```
```{r}
summary(npp.patho.low)$adj.r.squared
```
```{r}
summary(npp.patho.high)$adj.r.squared
```
## Structural equation modelling (SEM)
To analyse the network of environmental factors and hunter-gatherer population density, we used the
`piecewiseSEM` package in R to perform piecewise structural equation model separately to low and high
productivity regimes (see above).
### Function for the analysis of spatial autocorrelation
Following function allows to analyse the impact of spatial autocorrelation on piecewise SEM model. It takes
a single linear or generalized linear model or list of such models and longitude and latitude coordinates
of data points as input. The function is modified from lavSpatialCorrect function by Jarret Byrnes
(https://github.com/jebyrnes/spatial_correction_lavaan). This function is used below after fitting the SEM
models.
```{r}
require(ape)
require(fossil)

spatialCorrectL <- function(obj, xvar, yvar, alpha=0.05){
  if(class(obj)=="lm" || class(obj)=="glm"){
    resids <- residuals(obj)
    distMat <- as.matrix(earth.dist(cbind(xvar, yvar), dist=F))
    distsInv <- 1/distMat
    diag(distsInv) <- 0
    mi <- Moran.I(resids, distsInv)
    if(mi$p.value > alpha){
      mi$n.eff <- length(resids)
    }else{
      mi$n.eff <- length(resids)*(1-mi$observed)/(1+mi$observed)
    }
    v <- diag(vcov(obj))
    n <- length(resids)
    v2 <- v*n/mi$n.eff
    ret <- data.frame(Estimate=coef(obj),
                      n.eff = mi$n.eff, Std.err = sqrt(v2))
    ret[["Z-value"]] <- ret$Estimate/ret$Std.err
    ret[["P(>|z|)"]] <- 2*pnorm(abs(ret[["Z-value"]]), lower.tail=F)
    list1 <- list(mi, ret)
    names(list1) <- c(names(obj$model[1]),names(obj$model[1]))
    return(list1)
  } else {
    if(class(obj)=="list"){
      sp.corr.list <- list()
      for(i in 1:length(obj)){
        resids <- residuals(obj[[i]])
        distMat <- as.matrix(earth.dist(cbind(xvar, yvar),dist=F))
        distsInv <- 1/distMat
        diag(distsInv) <- 0
        mi <- Moran.I(resids, distsInv)
        if(mi$p.value > alpha){
          mi$n.eff <- length(resids)
        }else{
          mi$n.eff <- length(resids)*(1-mi$observed)/(1+mi$observed)
        }
        v <- diag(vcov(obj[[i]]))
        n <- length(resids)
        v2 <- v*n/mi$n.eff
        ret <- data.frame(Estimate=coef(obj[[i]]),
                          n.eff = mi$n.eff, Std.err = sqrt(v2))
        ret[["Z-value"]] <- ret$Estimate/ret$Std.err
        ret[["P(>|z|)"]] <- 2*pnorm(abs(ret[["Z-value"]]), lower.tail=F)
        list1 <- list(mi, ret)
        names(list1) <- c(names(obj[[i]]$model[1]),names(obj[[i]]$model[1]))
        sp.corr.list[[i]] <- list1
      }
      return(sp.corr.list)
    } else {
      "Warning: object is not lm or glm model object or list of such model objects"
    }
  }
}
```
### Fitting of structural equation models
We started the analysis with the structural equation (SE) model, where the direct effect of NPP is missing.
We built subsequent models by analysing the SE model fits and spatial autocorrelation statistics. Fits of SE
models are evaluated using the test of direct separation with Fisher C as a test statistic.
#### SE model to the low productivity environments
First, we fitted SE models to the low produtivity environments.
```{r}
data.low <- data[data$nrg=="lo",]
modelList1 <- list(
  lm(ldensityC ~ biodiv + pathos, data = data.low),
  lm(biodiv ~ npp, data=data.low),
  lm(pathos ~ npp + biodiv, data=data.low))
coefs(modelList1, standardize = "scale")
```
```{r}
m1 <- psem(
  lm(ldensityC ~ biodiv + pathos, data = data.low),
  lm(biodiv ~ npp, data=data.low),
  lm(pathos ~ npp + biodiv, data=data.low), data=data.low)
m1
```
```{r}
# All the paths are significant, but the test of directed separation (sem.fit)
# indicates that the direct effect of NPP is indeed important. So, add
# the direct effect of NPP to the equation.
summary(m1)
```

```{r}
modelList2 <- list(
lm(ldensityC ~ npp + biodiv + pathos, data = data.low),
lm(biodiv ~ npp, data=data.low),
lm(pathos ~ npp + biodiv, data=data.low))
coefs(modelList2, standardize = "scale")
```
```{r}
m2 <- psem(
lm(ldensityC ~ npp + biodiv + pathos, data = data.low),
lm(biodiv ~ npp, data=data.low),
lm(pathos ~ npp + biodiv, data=data.low))
m2
```
```{r}
summary(m2)
```

```{r}
# Now the model is fully saturated and sem.fit cannot give any estimate
# of model fit (naturally). However, now the direct effect of pathogens
# on population density is not significant, so we can remove it from the
# equation
modelList3 <- list(
lm(ldensityC ~ npp + biodiv, data = data.low),
lm(biodiv ~ npp, data=data.low),
lm(pathos ~ npp + biodiv, data=data.low))
coefs(modelList3, standardize = "scale")
```
```{r}
m3 <- psem(
lm(ldensityC ~ npp + biodiv, data = data.low),
lm(biodiv ~ npp, data=data.low),
lm(pathos ~ npp + biodiv, data=data.low), data=data.low)
m3
```
```{r}
summary(m3)
```
```{r}
plot(m3)
```
```{r}
# All fine for now, but we need to test how spatial autocorrelation
# influences our results. For full results (expected and observed Moran I, etc.)
# use spatialCorrectL(modelList3,data.low$longitude,data.low$latitude) without
# subsetting.
# First, effects on population density
spatialCorrectL(modelList3, x=data.low$longitude, y=data.low$latitude)[[1]][[2]]
```
```{r}
# The previous formula somehow ends up with data of different lengths.
c(nrow(data.low), length(residuals(modelList3[[1]])))
```
```{r}
# Next, effects on biodiversity
spatialCorrectL(modelList3,data.low$longitude,data.low$latitude)[[2]][[2]]
```
```{r}
# Lastly, effects on pathogen stress
spatialCorrectL(modelList3,data.low$longitude,data.low$latitude)[[3]][[2]]
```
```{r}
# Reults suggest that effect of NPP on pathogens is not
# significant when spatial autocorrelation present in the data
# is taken into account. We can remove that from the equation
modelList4 <- list(
lm(ldensityC ~ npp + biodiv, data = data.low),
lm(biodiv ~ npp, data=data.low),
lm(pathos ~ biodiv, data=data.low))
coefs(modelList4, standardize = "scale")
```
```{r}
m4 = psem(lm(ldensityC ~ npp + biodiv, data = data.low),
lm(biodiv ~ npp, data=data.low),
lm(pathos ~ biodiv, data=data.low), data=data.low)

m4
```
```{r}
plot(m4)
```
#### SE model to the high productivity environments
Again, we start with the model, where direct effect of NPP is missing.
```{r}
data.high <- data[data$nrg=="hi",]
modelList5 <- list(
  lm(ldensityC ~ biodiv + pathos, data = data.high),
  lm(biodiv ~ npp, data=data.high),
  lm(pathos ~ npp + biodiv, data=data.high))
coefs(
  lm(ldensityC ~ biodiv + pathos, data = data.high),
  lm(biodiv ~ npp, data=data.high),
  lm(pathos ~ npp + biodiv, data=data.high), standardize = "scale")
```
```{r}
m5 = psem(
  lm(ldensityC ~ biodiv + pathos, data = data.high),
  lm(biodiv ~ npp, data=data.high),
  lm(pathos ~ npp + biodiv, data=data.high), data=data.high)
m5
```
```{r}
summary(m5)
```
```{r}
plot(m5)
```
```{r}
# Results suggest that the direct effect should be included.
# Results also indicate that the effects of biodiversity are not
# significant, so we can remove them from the equation.
modelList6 <- list(
  lm(ldensityC ~ npp + pathos, data = data.high),
  lm(biodiv ~ npp, data=data.high),
  lm(pathos ~ npp, data=data.high))
coefs(modelList6, standardize = "scale")
```
```{r}
m6 <- psem(
  lm(ldensityC ~ npp + pathos, data = data.high),
  lm(biodiv ~ npp, data=data.high),
  lm(pathos ~ npp, data=data.high), data=data.high)
m6
```
```{r}
summary(m6)
```
```{r}
# Analysis for spatial autocorrelation.
# First, effects on population density.
spatialCorrectL(modelList6,data.high$longitude,data.high$latitude)[[1]][[2]]
```
```{r}
# Effects on biodiversity.
spatialCorrectL(modelList6,data.high$longitude,data.high$latitude)[[2]][[2]]
```
```{r}
# Effects on pathogen stress.
spatialCorrectL(modelList6,data.high$longitude,data.high$latitude)[[3]][[2]]
```
This last (m6) will our final model for high productivity, because analysis of spatial autocor-
relation suggests that all paths are significant even when spatial autocorrelation is taken into account.
```{r}
plot(m6)
```
### Partial residuals and predictive power of the SE model
We plotted partial residual plots of the effects of the predictors in the SE-model, and calculated the predictive
power of the piecewice model in the whole data (low and high combined).
```{r}
# Fit component models explaining population density
fit.dens.low <- lm(ldensityC ~ npp + biodiv, data=data[data$nrg=="lo",])
fit.dens.high <- lm(ldensityC ~ npp + pathos, data=data[data$nrg=="hi",])
# Fit component models that also include non-significant predictors
fit.dens.low2 <- lm(ldensityC ~ npp + biodiv + pathos, data=data[data$nrg=="lo",])
fit.dens.high2 <- lm(ldensityC ~ npp + biodiv + pathos, data=data[data$nrg=="hi",])
# Partial residual plots for models that include also non-significant predictors.
# The same code can be applied to the models including only significant predictors
par(mfrow=c(2,3), mar=c(4,4,3,0.5))
visreg(fit.dens.low2, "npp", points=list(cex=0.8, pch=1, col="black"), xlab="",
  ylab="ln(Pop. density)", ylim=c(-2,6), xlim=c(100,1500))
visreg(fit.dens.low2, "biodiv", points=list(cex=0.8, pch=1, col="black"),
  main="Low-productivity", xlab="", ylab="", ylim=c(-2,6), xlim=c(0,0.5), yaxt="n")
visreg(fit.dens.low2, "pathos", points=list(cex=0.8, pch=1, col="black"),
  xlab="", ylab="", ylim=c(-2,6), xlim=c(-1,1), yaxt="n")
visreg(fit.dens.high2, "npp", points=list(cex=0.8, pch=1, col="black"),
  xlab="NPP", ylab="ln(Pop. density)", ylim=c(0,6))
visreg(fit.dens.high2, "biodiv", points=list(cex=0.8, pch=1, col="black"),
  main="High-productivity", xlab="Biodiversity", ylab="", ylim=c(0,6),
  xlim=c(0.1,0.7), yaxt="n")
visreg(fit.dens.high2, "pathos", points=list(cex=0.8, pch=1, col="black"),
  xlab="Pathogens", ylab="", ylim=c(0,6), xlim=c(-1,0.2), yaxt="n")
```
```{r}
# Predictive power
pred <-vector()
for(i in 1:nrow(data)){
  case <- data[i,]
  if(case$nrg == "lo"){
    pred[i] <- predict(fit.dens.low, case)
  } else {
    pred[i] <- predict(fit.dens.high, case)
  }
  return=pred
}
# Adjusted R square
summary(lm(data$ldensityC~pred))$adj.r.squared
```
### Direct, indirect, and total effects of predictors on population density
These effects are based on standardized regression coefficients.
```{r}
# Direct effects (all)
coeffs.low <- coefs(modelList4, standardize = "scale")[,1:3]
coeffs.high <- coefs(modelList6, standardize = "scale")[,1:3]
# For low productivity environments:
# Direct effect of npp on population density.
npp.dir.low <- coeffs.low[2,3]
# Indirect effects of npp on population
# density via biodiversity.
npp.ind.low <- coeffs.low[3,3] * coeffs.low[1,3]
# Total effect of npp on population density.
npp.tot.low <- npp.dir.low + npp.ind.low
# Direct, indirect and total effects of
# biodiversity on population density.
biod.dir.low <- coeffs.low[1,3]
biod.ind.low <- NA
biod.tot.low <- coeffs.low[1,3]
# Direct, indirect and total effects of
# pathogen stress on population density.
path.dir.low <- NA
path.ind.low <- NA
path.tot.low <- NA
# For high productivity environments:
# Direct effect of npp on population density.
npp.dir.high <- coeffs.high[2,3]
# Indirect effects of npp on population
# density via pathogen stress.
npp.ind.high <- coeffs.high[4,3] * coeffs.high[1,3]
# Total effect of npp on population density.
npp.tot.high <- npp.dir.high + npp.ind.high
# Direct, indirect and total effects of
# biodiversity on population density.
biod.dir.high <- NA
biod.ind.high <- NA
biod.tot.high <- NA
# Direct, indirect and total effects of
# pathogen stress on population density.
path.dir.high <- coeffs.high[1,3]
path.ind.high <- NA
path.tot.high <- coeffs.high[1,3]
```
Tables of effects
Table 1: Effects in low productivity environments
Table 2: Effects in high productivity environments

### Linear model with interactions
In order to see whether the same kind of pattern can be observed when the data are not split into low- and high-
productivity sets, we performed linear model to explain population density using the whole dataset. In this
model we included interactions between NPP and pathogen stress and between NPP and biodiversity. These
results show the same pattern and strongly suggest that the differences between low- and high-productivity
environments observed in the SEM analyses is not an artefact of splitting the data.
```{r}
linear.m <- lm(ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv, data=data)
# center variables to get meaningful main effects and p-values
summ(linear.m, vifs=TRUE, center=TRUE)
```
Model diagnostics and interactive effects show that the model performs reasonably well and that the
relationships between variables resemble to that of the SEM results.
```{r}
par(mfrow=c(1,2))
qqPlot(linear.m, main="QQ Plot", col="black",pch=0,cex=2, col.lines="red",envelope=F,
las=1,line="quartiles")
resids <- as.vector(linear.m$residuals)
fitted <- as.vector(linear.m$fitted.values)
plot(fitted,resids, las=1, pch=0, cex=2)
abline(lm(resids~fitted))
lines(fitted[order(fitted)],predict(loess(resids~fitted, span=0.75))[order(fitted)],
lwd=2, col="red")
```
```{r}
interact_plot(linear.m, pred = "pathos", modx = "npp", interval = TRUE,
  modxvals=quantile(data$npp, prob=c(0.1, 0.5, 0.9)))
```
The above figure shows how the effect of pathogen stress on population density changes when NPP changes.
```{r}
interact_plot(linear.m, pred = "biodiv", modx = "npp", interval = TRUE,
modxvals=quantile(data$npp, prob=c(0.1,0.5,0.9)))
```
The above figure shows how the effect of biodiversity on population density changes when NPP changes.
## Global projection of hunter-gatherer population density and its constraints
We produced the global projection using a combination (average) of two modelling techniques: OLS linear
regression (LM) and support vector regression (SVR) with linear kernel. We fitted these modelling algorithms
to the whole data, i.e., over the entire NPP gradient. We used resulting models to predict global ln(population
density) using global environmental variables (see above) as predictor variables. Both of the models include
interactions between NPP and biodiversity and between NPP and pathogen stress.
### Performance of the prediction model
We evaluated the preformance of the averaged prediction model by $h$-block CV. We used 500 km as a
h-value in the CV. We adapted the code for h-block CV from the supplement of the Salonen et al. (2016)
(http://www.helsinki.fi/~ssalonen/txt/Salonen_ea2016-Holocene-Tree_ensembles-v2.pdf).
```{r}
# Hyperparameter values for the SVR model
kernel <- "linear"
cost <- 0.5
epsilon <- 0.1

distMat <- as.matrix(earth.dist(cbind(data$longitude,data$latitude),dist=F))
h.value <- 500
preds.ens <- vector(mode = "numeric", length = nrow(data))


for (i in 1:nrow(data)) {
  test.rows <- 1:nrow(data) == i
  # test row indices
  # for iteration i
  train.rows <-
    !test.rows & distMat[, i] > h.value # train row indices
  # for iteration i
  train.iter <- data[train.rows,]
  # training data used for
  # the iteration i
  test.iter <- data[test.rows,]
  # test data used for
  # the iteration i
  lm.m <-
    lm(ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv,
       data = train.iter)
  svm.m <-
    svm(
      ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv,
      kernel = kernel,
      cost = cost,
      epsilon = epsilon,
      data = train.iter
    )
  lm.p <- predict(lm.m, newdata = test.iter)
  svm.p <- predict(svm.m, type = "response", newdata = test.iter)
  preds.ens[i] <- rowMeans(cbind(lm.p, svm.p))
}

rmse <- sqrt(mean((preds.ens - data$ldensityC) ^ 2))
rmse
```
```{r}
r2 <- summary(lm(data$ldensityC~preds.ens))$adj.r.squared
r2
```
$H$-block cross-validated RMSE (1.26) and R² (`{r} r2`) indicate that the ensemble model is performing well with
the data that algorithms haven’t seen before.

The same approach can be used to evaluate individual techniques:
```{r}
# First for the linear model
distMat <-
  as.matrix(earth.dist(cbind(data$longitude, data$latitude), dist = F))
h.value = 500
preds.lm <- vector(mode = "numeric", length = nrow(data))

for (j in 1:nrow(data)) {
  test.rows <- 1:nrow(data) == j
  train.rows <- !test.rows & distMat[, j] > h.value
  train.iter <- data[train.rows,]
  test.iter <- data[test.rows,]
  lm.l <-
    lm(ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv,
       data = train.iter)
  preds.lm[j] <- predict(lm.l, newdata = test.iter)
  preds.lm
}

# RMSE
sqrt(mean((preds.lm - data$ldensityC) ^ 2))
```
```{r}
# R2
summary(lm(data$ldensityC~preds.lm))$adj.r.squared
```
```{r}
# bias (under- or overestimation)
abs(1-coefficients(lm(data$ldensityC~preds.lm))[[2]])
```
```{r}
# Then for the SVR
distMat <-
  as.matrix(earth.dist(cbind(data$longitude, data$latitude), dist = F))
h.value = 500
preds.svm <- vector(mode = "numeric", length = nrow(data))


for (j in 1:nrow(data)) {
  test.rows <- 1:nrow(data) == j
  train.rows <- !test.rows & distMat[, j] > h.value
  train.iter <- data[train.rows,]
  test.iter <- data[test.rows,]
  svm.l <-
    svm(
      ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv,
      data = train.iter,
      kernel = "linear",
      cost = 0.5,
      epsilon = 0.1
    )
  preds.svm[j] <- predict(svm.l, newdata = test.iter)[1]
  preds.svm
}

# RMSE
sqrt(mean((preds.svm - data$ldensityC) ^ 2))
```
```{r}
# R2
summary(lm(data$ldensityC~preds.svm))$adj.r.squared
```
```{r}
# bias (under- or overestimation)
abs(1-coefficients(lm(data$ldensityC~preds.svm))[[2]])
```

```{r}
par(mfrow=c(1,2))
plot(data$ldensityC, preds.lm, pch=0, ylim=c(-2,6), xlim=c(-2,6), las=1,
ylab="Predicted (LM)", xlab="Observed")
abline(0,1, col="red")
abline(lm(data$ldensityC~preds.lm))

plot(data$ldensityC, preds.svm, pch=0, ylim=c(-2,6), xlim=c(-2,6), las=1,
ylab="Predicted (SVR)", xlab="Observed")
abline(0,1, col="red")
abline(lm(data$ldensityC~preds.svm))
```
### Final models used in the prediction
```{r}
lm.mod <- lm(ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv, data=data)

svm.mod <- svm(ldensityC ~ npp + biodiv + pathos + npp:pathos + npp:biodiv,
  kernel="linear", cost=0.5, epsilon=0.1, data=data)
```
Plots of the effects of the three predictors on population density
```{r}
par(mfcol=c(2,2), mar=c(1,1,1,1))
visreg2d(lm.mod, "biodiv", "npp", plot.type="persp", col="lightblue",
theta=-50, phi=20, nn=20, main="LM", ticktype = "simple")
visreg2d(lm.mod, "npp", "pathos", plot.type="persp", col="lightblue",
theta=-123, phi=14, nn=20, main="LM", ticktype = "simple")
visreg2d(svm.mod, "biodiv", "npp", plot.type="persp",col="lightblue",
theta=-50, phi=20, nn=20, main="SVR", ticktype = "simple")
visreg2d(svm.mod, "npp", "pathos", plot.type="persp",col="lightblue",
theta=-123, phi=14, nn=20, main="SVR", ticktype = "simple")
```
### Global dataset of predicted hunter-gatherer population density
Here, we use the combination of the two models to construct a global projection hunter-gatherer population
density. This projection or prediction assumes that the whole world would be populated by hunter-gatherers
only. Global map shows the distribution of hunter-gatherer population density given the effects of NPP,
biodiversity, and pathogen stress.
```{r}
# Create global predictor dataset, which is based on the predictor
# raster stack created above
global.data <- as.data.frame(predictors, xy=TRUE)
names(global.data) <- c("x","y","npp","biodiv","pathos")
# Subset NA:s as a separate dataset.
globalNA <- as.data.frame(global.data[!complete.cases(global.data),])
row.names(globalNA) <- NULL
# add four "empty" variables, i.e., population densities predicted by three different
# modelling techniques.
globalNA$ldensitylm <- NA
globalNA$ldensitysvm <- NA
# Subset all the non-NA:s as a separate dataset.
global.data2 <- as.data.frame(global.data[complete.cases(global.data),])
row.names(global.data2) <- NULL
# Predict h-g population density using the fitted model algorithms (see above)
global.data2$ldensitylm <- predict(lm.mod, newdata=global.data2)
global.data2$ldensitysvm <- predict(svm.mod, type="response", newdata=global.data2)
# Combine predictions and NA:s
global.preds <- rbind(global.data2,globalNA)
# Calculate ensemble projection (mean of three predictions)
global.preds$lensemble <- apply(global.preds[,6:7], 1, mean)
# Add variable indicating high population density areas (pop.dens. > 85th percentile)
global.preds$hidens <- ifelse(global.preds$lensemble > quantile(global.preds$lensemble,
0.85, na.rm=T),1,0)
# Rasterize the global projection
global.stack <- rasterFromXYZ(global.preds)
```
Next, the global map pf predicted population density. The same code can be used for creating maps of LM
and SVR predictions individually.
```{r}
# Plot the ensemble prediction
# First, download glaciers data from http://www.naturalearthdata.com/
# (just for the illustration), then define breaks and colors for mapping density,
# and finally plot the map.
# Glaciers data
URL <- paste(
  "https://www.naturalearthdata.com",
  "http//www.naturalearthdata.com",
  "download/50m/physical",
  "ne_50m_glaciated_areas.zip?version=2.0.0",
  # I had problems downloading the current version, but 2.0.0 I could get.
  sep="/")
wd <- getwd()
td <- tempdir()
setwd(td)
temp <- tempfile(fileext = ".zip")
download.file(URL, temp, mode = "wb")
unzip(temp)
shp <- dir(tempdir(), "*.shp$")
lyr <- sub(".shp$", "", shp)
glaciers <- readOGR(dsn = shp, layer = lyr)
unlink(dir(td))
setwd(wd)
crs(glaciers) <- "+proj=longlat +datum=WGS84"
```

```{r}
steps = 12

# Take ensemble projection as a separate layer
lpdensity <- global.stack[[6]]
# Define breaks in the ln(population density)
t.steps <- 0:steps
x.min <- cellStats(lpdensity, stat = "min")
step.len <-
  (cellStats(lpdensity, stat = "max") - cellStats(lpdensity, stat = "min")) /
  steps
breaks <- vector()

for (i in 1:length(t.steps)) {
  breaks[i] <- x.min + t.steps[i] * step.len
  return = breaks
}

# Define colors
col <- viridis(steps)

# Finally, the global map itself
par(mar = c(0, 0, 0, 0))
image(
  lpdensity,
  col = col,
  breaks = breaks,
  asp = 1,
  main = "",
  xlab = "",
  ylab = "",
  axes = F,
  xlim = c(-180, 180)
)
text(0, 90, "Predicted population density")
plot(glaciers,
     col = "white",
     border = "white",
     add = T)
# Legend
legend_cat_width <- 10
legend_height <- 10
legend_xleft <- -45
legend_ybottom <- -65
legend_ytop <- legend_ybottom + legend_height
for (k in 1:length(col)) {
  rect(
    legend_xleft + (k - 1) * legend_cat_width,
    legend_ybottom,
    legend_xleft + k * legend_cat_width,
    legend_ytop,
    border = "black",
    col = col[k],
    lwd = 0.6
  )
}

text(
  legend_xleft + 4 * legend_cat_width,
  legend_ytop + legend_height / 2,
  labels = "ln(Population density)",
  family = "sans",
  cex = 0.9
)
text(
  c(0, 3, 6, 9, 12) * legend_cat_width + legend_xleft,
  rep(legend_ybottom - 0.8 * legend_height, 3),
  labels = c(
    round(breaks[1], 1),
    round(breaks[4], 1),
    round(breaks[7], 1),
    round(breaks[10], 1),
    round(breaks[13], 1)
  ),
  family = "sans",
  cex = .9
)
```
Correlation between LM and SVR global predictions
```{r}
global_lm <- global.stack[[4]]
global_svm <- global.stack[[5]]
lm_svm_stack <- stack(global_lm, global_svm)
layerStats(lm_svm_stack, "pearson", na.rm=TRUE)
```
```{r}
smoothScatter(values(global_lm), values(global_svm), nrpoints=0,
xlab="Prediction (LM)", ylab="Prediction (SVM)")
abline(0,1, col="red", lwd=2)
```
High-density areas (population density > 85th percentile)
```{r}
plot(global.stack[[7]], main="High-density areas",xlab="",ylab="", col=c("grey","red"), axes=F)
plot(glaciers, col="white", border="white", add=T)
points(data$longitude,data$latitude, pch=16, col="black", cex=0.3)
```
### Analysis of limiting factors
To analyze where NPP, biodiversity, and pathogen stress potentially have the strongest limiting effects on
population density, we first determined optimum values of each predictor variables. Next, we created three
global data sets where where each of the predictor variables was set to its optimum, while other two variables
remained untouched. Then, we produced three global projections of population densities using these predictor
data sets. This resulted in three different predictions of population density. Finally, we subtracted original
“true” population density predictions (see above) from these “optimum” predictions. For example, the larger
the difference between prediction, where NPP was set to its optimum value, and the original prediction,
the larger the limiting effect of NPP. Absolute differences (some were negative) between “optimum” and
original predictions were scaled to vary between 0 and 1. For the three-band RGB color map these values
were multiplied by 255.
#### Finding optimums of predictors
```{r}
# Finding optimums of predictor variables
# First, create a dataset where the target variable (the one whose optimum
# we are interested in) is allowed to vary and other two variables are set
# to their mean.
dNPPopt <- data[,c("ldensityC","npp")]
dNPPopt$biodiv <- mean(data$biodiv)
dNPPopt$pathos <- mean(data$pathos)
row.names(dNPPopt) <- NULL
dBIOopt <- data[,c("ldensityC","biodiv")]
dBIOopt$npp <- mean(data$npp)
dBIOopt$pathos <- mean(data$pathos)
row.names(dBIOopt) <- NULL
dPATopt <- data[,c("ldensityC","pathos")]
dPATopt$npp <- mean(data$npp)
dPATopt$biodiv <- mean(data$biodiv)
row.names(dPATopt) <- NULL
# Next, predict population density to these data.
# NPP optimum
svm.prds.NPPopt <- predict(svm.mod, type = "response", newdata = dNPPopt)
lm.prds.NPPopt <- predict(lm.mod, newdata = dNPPopt)
prds.NPPopt <- rowMeans(cbind(svm.prds.NPPopt, lm.prds.NPPopt))
# Biodiversity optimum
svm.prds.BIOopt <- predict(svm.mod, type = "response", newdata = dBIOopt)
lm.prds.BIOopt <- predict(lm.mod, newdata = dBIOopt)
prds.BIOopt <- rowMeans(cbind(svm.prds.BIOopt, lm.prds.BIOopt))
# Pathogen stress optimum
svm.prds.PATopt <- predict(svm.mod, type = "response", newdata = dPATopt)
lm.prds.PATopt <- predict(lm.mod, newdata = dPATopt)
prds.PATopt <- rowMeans(cbind(svm.prds.PATopt, lm.prds.PATopt))
# Plot optimums
par(mfrow=c(3,1), mar=c(4,4,2,1))
plot(data$npp,prds.NPPopt, xlab="NPP", ylab="pred. Population density",
  main="Optimums of environmental variables")
abline(v=data$npp[which.max(prds.NPPopt)])
text(data$npp[which.max(prds.NPPopt)],2,round(data$npp[which.max(prds.NPPopt)],0))
plot(data$biodiv,prds.BIOopt, xlab="Biodiversity", ylab="pred. Population density")
abline(v=data$biodiv[which.max(prds.BIOopt)])
text(data$biodiv[which.max(prds.BIOopt)],2.5,
round(data$biodiv[which.max(prds.BIOopt)],2))
plot(data$pathos,prds.PATopt, xlab="Pathogen stress", ylab="pred. Population density")
abline(v=data$pathos[which.max(prds.PATopt)])
text(data$pathos[which.max(prds.PATopt)],1.5,
round(data$pathos[which.max(prds.PATopt)],2))
```
#### Limiting effect of NPP in the global dataset.
```{r}
# First, create a global dataset based on global predictor data that.
# This is done along the same lines as the original global data.
glb.data.opti.npp <- as.data.frame(predictors, xy=TRUE)
names(glb.data.opti.npp) <- c("x","y","npp","biodiv","pathos")
# Subset NA:s as a separate dataset.
glb.npp.opti.NA <- as.data.frame(glb.data.opti.npp[!complete.cases(glb.data.opti.npp),])
row.names(glb.npp.opti.NA) <- NULL
# Add three "empty" variables.
glb.npp.opti.NA$ldensitylm <- NA
glb.npp.opti.NA$ldensitysvm <- NA
# Subset all the non-NA:s as a separate dataset.
glb.data2.opti.npp <- as.data.frame(glb.data.opti.npp[complete.cases(glb.data.opti.npp),])
row.names(glb.data2.opti.npp) <- NULL
# Set NPP values to its optimum
glb.data2.opti.npp$npp <- data$npp[which.max(prds.NPPopt)]
40# Predict h-g population density using the fitted model algorithms (see above)
glb.data2.opti.npp$ldensitylm <- predict(lm.mod, newdata=glb.data2.opti.npp)
glb.data2.opti.npp$ldensitysvm <- predict(svm.mod, type = "response",
newdata=glb.data2.opti.npp)
# Combine predictions and NA:s
glb.preds.npp.opti <- rbind(glb.data2.opti.npp,glb.npp.opti.NA)
# Calculate ensemble projection (prediction)
glb.preds.npp.opti$lensemble <- apply(glb.preds.npp.opti[,6:7], 1, mean)
# Difference between "real" and optimized
npp.effectL <- glb.preds.npp.opti$lensemble-global.preds$lensemble
# Absolute differences
npp.effectLABS <- abs(npp.effectL)
```
#### Limiting effect of biodiversity in the global dataset.
```{r}
glb.data.opti.bio <- as.data.frame(predictors, xy=TRUE)
names(glb.data.opti.bio) <- c("x","y","npp","biodiv","pathos")
glb.bio.opti.NA <- as.data.frame(glb.data.opti.bio[!complete.cases(glb.data.opti.bio),])
row.names(glb.bio.opti.NA) <- NULL
glb.bio.opti.NA$ldensitylm <- NA
glb.bio.opti.NA$ldensitysvm <- NA
glb.data2.opti.bio <- as.data.frame(glb.data.opti.bio[complete.cases(glb.data.opti.bio),])
row.names(glb.data2.opti.bio) <- NULL
glb.data2.opti.bio$biodiv <- data$biodiv[which.max(prds.BIOopt)]
glb.data2.opti.bio$ldensitylm <- predict(lm.mod, newdata=glb.data2.opti.bio)
glb.data2.opti.bio$ldensitysvm <- predict(svm.mod, type = "response",
newdata=glb.data2.opti.bio)
glb.preds.bio.opti <- rbind(glb.data2.opti.bio,glb.bio.opti.NA)
glb.preds.bio.opti$lensemble <- apply(glb.preds.bio.opti[,6:7], 1, mean)
bio.effectL <- glb.preds.bio.opti$lensemble-global.preds$lensemble
bio.effectLABS <- abs(bio.effectL)
```
#### Limiting effect of pathogens in the global dataset.
```{r}
glb.data.opti.pat <- as.data.frame(predictors, xy=TRUE)
names(glb.data.opti.pat) <- c("x","y","npp","biodiv","pathos")
glb.pat.opti.NA <- as.data.frame(glb.data.opti.pat[!complete.cases(glb.data.opti.pat),])
row.names(glb.pat.opti.NA) <- NULL
glb.pat.opti.NA$ldensitylm <- NA
glb.pat.opti.NA$ldensitysvm <- NA
glb.data2.opti.pat <- as.data.frame(glb.data.opti.pat[complete.cases(glb.data.opti.pat),])
row.names(glb.data2.opti.pat) <- NULL
glb.data2.opti.pat$pathos <- data$pathos[which.max(prds.PATopt)]
glb.data2.opti.pat$ldensitylm <- predict(lm.mod, newdata=glb.data2.opti.pat)
glb.data2.opti.pat$ldensitysvm <- predict(svm.mod, type = "response",
newdata=glb.data2.opti.pat)
glb.preds.pat.opti <- rbind(glb.data2.opti.pat,glb.pat.opti.NA)
glb.preds.pat.opti$lensemble <- apply(glb.preds.pat.opti[,6:7], 1, mean)
pat.effectL <- glb.preds.pat.opti$lensemble-global.preds$lensemble
pat.effectLABS <- abs(pat.effectL)
```
#### Scaling and plotting of the limiting effects
We scaled absolute differences and considered these as measures of the strength of the limiting effect of given
environmental variable. Then we created global raster layers of each limiting effects. Finally we plotted the
geographical distribution of the limiting effects using plotRGB function in raster R package.
```{r}
# Scaling of absolute differences.
# First, a matrix of limiting effects of NPP, biodiversity, and pathogen stress
effects.mat <-
  as.data.frame(cbind(npp.effectLABS, bio.effectLABS, pat.effectLABS))
# Scaling function that scales absolute differences between 0 and 1.
standardRow <- function(z) {
  rowmax <- apply(z, 1, max) # row max
  rv <- sweep(z, 1, rowmax, "/") # dividing by row maximum
  return(rv)
}
effects.mat.strdR <- standardRow(effects.mat)
# Scale to RGB values
effects.mat.strdR.rgb <- effects.mat.strdR * 255
# Create rasters of limiting effects
effects.strdR.npp.rast <-
  rasterFromXYZ(cbind(glb.preds.npp.opti[, c("x", "y")],
                      effects.mat.strdR.rgb[[1]]))
effects.strdR.bio.rast <-
  rasterFromXYZ(cbind(glb.preds.bio.opti[, c("x", "y")],
                      effects.mat.strdR.rgb[[2]]))
effects.strdR.pat.rast <-
  rasterFromXYZ(cbind(glb.preds.pat.opti[, c("x", "y")],
                      effects.mat.strdR.rgb[[3]]))
# Plot the geographical distribution of limiting effects
# Function for for legend
# Coordinates of the triangle
tri <- rbind(sin(0:2 * 2 / 3 * pi), cos(0:2 * 2 / 3 * pi))
# Function for calculating the color of a set of points `pt`
# in relation to the triangle
tricol <- function(pt, sharpness = 2) {
  require(splancs)
  RGB <- sapply(1:3, function(i) {
    a <- sweep(pt, 2, tri[, i])
    b <- apply(tri[, -i], 1, mean) - tri[, i]
    sharpness * ((a %*% b) / sum(b ^ 2)) - sharpness + 1
  })
  alpha <- rep(1, nrow(pt))
  RGB <- cbind(RGB, alpha)
  RGB[-inpip(pt, t(tri)), ] <- 0
  # Color points outside the triangle white
  do.call(rgb, unname(as.data.frame(pmin(pmax(
    RGB, 0
  ), 1))))
}
par(mar = c(0, 0, 0, 0), mfrow = c(1, 1))
image(
  lpdensity,
  col = col,
  breaks = breaks,
  asp = 1,
  main = "",
  xlab = "",
  ylab = "",
  axes = F,
  xlim = c(-180, 180)
)
plotRGB(
  stack(
    effects.strdR.npp.rast,
    effects.strdR.bio.rast,
    effects.strdR.pat.rast
  ),
  r = 3,
  g = 1,
  b = 2,
  stretch = "lin",
  bgalpha = 0,
  add = T
)
text(0, 90, "Geographical distribution of limiting effects")
plot(glaciers,
     col = "white",
     border = "white",
     add = T)
# Plot legend
res <- 1000
# Resolution
xi <- seq(-1, 1, length = res)
# Axis points
yi <- seq(-.8, 1.2, length = res)
x <- xi[1] + cumsum(diff(xi))
# Midpoints between axis points
y <- yi[1] + cumsum(diff(yi))
xy <- matrix(1:(length(x) * length(y)), length(x))
par(fig = c(0.05, 0.25, 0.30, 0.5), new = T)
image(
  xi,
  yi,
  xy,
  col = tricol(as.matrix(expand.grid(x, y)),
               sharpness = 1.6),
  useRaster = T,
  xlab = "",
  ylab = "",
  axes = F
)
text(0.0, -0.65, "Pathogens")
text(0.6, 0.3, "Biodiversity", srt = -50)
text(-0.7, 0.3, "NPP", srt = 50)
```
### Biome-wise analyses
We also wanted to explore biome-wise differences in the predicted
hunter-gatherer population density and limiting effects of environmental
variables. Information on biomes is extracted from Ecoregions 2017 (related
citation: [@dinerstein2017ecoregionbased]), which has biomes compatible with a
selection of 846 medium-scale worldwide ecoregions, useful for a subsequent
analysis. We scaled limiting effects of different predictors to sum to unity
(for illustrative purposes), stacked them with ecological zones and population
density data. Finally, we calculated mean and maximum values of log population
density and mean values of limiting effects in different biomes and plotted
these as boxplots.
```{r}
# Download biome data.
URL <- paste("http://www.fao.org/geonetwork/srv/en",
"resources.get?id=47105&fname=gez2010.zip&access=private", sep="/")
URL <- paste("https://storage.googleapis.com",
             "teow2016",
             "Ecoregions2017.zip", sep="/")
wd <- getwd()
td <- tempdir()
setwd(td)
temp <- tempfile(fileext = ".zip")
download.file(URL, temp, mode="wb")
unzip(temp)
shp <- dir(tempdir(), "*.shp$")
lyr <- sub(".shp$", "", shp)
ecozon <- readOGR(dsn=shp, layer=lyr)
unlink(dir(td))
setwd(wd)
```
```{r}
# Create a raster mask to rasterize polygon data ##
worldRaster <- nppRast
worldRaster[!is.na(worldRaster)] <- 0
# and rasterize
ecozonRast <- rasterize(ecozon, worldRaster)

summary(ecozonRast)
```


```{r}
# Scale absolute differences so that they sum to unity
unityRow <- function(z) {
  rowsum <- apply(z, 1, sum) # row sum
  rv <- sweep(z, 1, rowsum,"/") # dividing by row sum
  return(rv)
}


effects.mat.unity <- unityRow(effects.mat)
effects.unity.npp.rast <-
  rasterFromXYZ(cbind(glb.preds.npp.opti[, c("x", "y")],
                      effects.mat.unity[[1]]))
effects.unity.bio.rast <-
  rasterFromXYZ(cbind(glb.preds.bio.opti[, c("x", "y")],
                      effects.mat.unity[[2]]))
effects.unity.pat.rast <-
  rasterFromXYZ(cbind(glb.preds.pat.opti[, c("x", "y")],
                      effects.mat.unity[[3]]))
# Stack global ensemble projection with the eco-zones raster
# Fix projections.
crs(ecozonRast) <- "+proj=longlat +datum=WGS84"
crs(lpdensity) <- "+proj=longlat +datum=WGS84"
crs(effects.strdR.npp.rast) <- "+proj=longlat +datum=WGS84"
crs(effects.strdR.bio.rast) <- "+proj=longlat +datum=WGS84"
crs(effects.strdR.pat.rast) <- "+proj=longlat +datum=WGS84"
crs(effects.unity.npp.rast) <- "+proj=longlat +datum=WGS84"
crs(effects.unity.bio.rast) <- "+proj=longlat +datum=WGS84"
crs(effects.unity.pat.rast) <- "+proj=longlat +datum=WGS84"
ecozStack <-
  stack(
    lpdensity,
    effects.unity.npp.rast,
    effects.unity.bio.rast,
    effects.unity.pat.rast,
    ecozonRast
  )
# Make a data frame.
ecozData <- as.data.frame(ecozStack, xy = T)
# Remove NA:s
ecozData <- ecozData[complete.cases(ecozData),]
```
```{r}
names(ecozData)[1:6] <- c("x", "y", "ldensity", "nppEffectL", "bioEffectL", "patEffectL")

ecozData$zcode <- NA
ecozData$zcode[ecozData$layer_BIOME_NAME=="Tundra"] <- 1
ecozData$zcode[ecozData$layer_BIOME_NAME=="Boreal Forests/Taiga"] <- 2
ecozData$zcode[ecozData$layer_BIOME_NAME=="Montane Grasslands & Shrublands"] <- 3
ecozData$zcode[ecozData$layer_BIOME_NAME=="Temperate Conifer Forests"] <- 4
ecozData$zcode[ecozData$layer_BIOME_NAME=="Temperate Broadleaf & Mixed Forests"] <- 5
ecozData$zcode[ecozData$layer_BIOME_NAME=="Temperate Grasslands, Savannas & Shrublands"] <- 6
ecozData$zcode[ecozData$layer_BIOME_NAME=="Mediterranean Forests, Woodlands & Scrub"] <- 7
ecozData$zcode[ecozData$layer_BIOME_NAME=="Deserts & Xeric Shrublands"] <- 8
ecozData$zcode[ecozData$layer_BIOME_NAME=="Tropical & Subtropical Grasslands, Savannas & Shrublands"] <- 9
ecozData$zcode[ecozData$layer_BIOME_NAME=="Flooded Grasslands & Savannas"] <- 10
ecozData$zcode[ecozData$layer_BIOME_NAME=="Mangroves"] <- 11
ecozData$zcode[ecozData$layer_BIOME_NAME=="Tropical & Subtropical Moist Broadleaf Forests"] <- 12
ecozData$zcode[ecozData$layer_BIOME_NAME=="Tropical & Subtropical Dry Broadleaf Forests"] <- 13
ecozData$zcode[ecozData$layer_BIOME_NAME=="Tropical & Subtropical Coniferous Forests"] <- 14

# Add new variable to use in the plotting (for ordering the zones)
ecozData$zcode <- as.factor(ecozData$zcode)
```

```{r}
# Calculate mean and max population densities per ecoregion
means_by_ecoregion <- aggregate(ldensity ~ layer_OBJECTID, ecozData, mean)
row.names(means_by_ecoregion) <- unique(ecozData$layer_ECO_NAME[order(ecozData$layer_OBJECTID)])
# Mean population density
write.csv(means_by_ecoregion, "ecoregion_mean_log_pop_density.csv")
means_by_ecoregion[order(means_by_ecoregion$ldensity, decreasing=TRUE),]
```

```{r}
steps = 12

# Define breaks in the ln(population density)
t.steps <- 0:steps
x.min <- cellStats(ecozonRast, stat = "min")
step.len <-
  (cellStats(ecozonRast, stat = "max") - cellStats(ecozonRast, stat = "min")) /
  steps
breaks <- vector()

for (i in 1:length(t.steps)) {
  breaks[i] <- x.min + t.steps[i] * step.len
  return = breaks
}

# Define colors
col <- viridis(steps)

# Finally, the global map itself
par(mar = c(0, 0, 0, 0))

image(
  ecozonRast,
  col = col,
  breaks = breaks,
  asp = 1,
  main = "",
  xlab = "",
  ylab = "",
  axes = F,
  xlim = c(-180, 180)
)
```

```{r}
# Calculate mean and max population densities per eco zone
means <- aggregate(ldensity ~ zcode, ecozData, mean)
row.names(means) <- unique(ecozData$zone[order(ecozData$zcode)])
# Mean population density
means[order(means$ldensity, decreasing=TRUE),]
```
```{r}
maxs <- aggregate(ldensity ~ zcode, ecozData, max)
row.names(maxs) <- unique(ecozData$zone[order(ecozData$zcode)])
# Maximum population density
maxs[order(maxs$ldensity, decreasing=TRUE),]
```
```{r}
# Mean limiting effect of different predictors
meansNPPEF <- aggregate(nppEffectL ~ zcode, ecozData, mean)
row.names(meansNPPEF) <- unique(ecozData$zone[order(ecozData$zcode)])
# Mean limiting effect of NPP
meansNPPEF[order(meansNPPEF$nppEffectL, decreasing=TRUE),]
```
```{r}
meansBIOEF <- aggregate(bioEffectL ~ zcode, ecozData, mean)
row.names(meansBIOEF) <- unique(ecozData$zone[order(ecozData$zcode)])
# Mean limiting effect of biodiversity
meansBIOEF[order(meansBIOEF$bioEffectL, decreasing=TRUE),]
```
```{r}
meansPATEF <- aggregate(patEffectL ~ zcode, ecozData, mean)
row.names(meansPATEF) <- unique(ecozData$zone[order(ecozData$zcode)])
# Mean limiting effect of pathogens
meansPATEF[order(meansPATEF$patEffectL, decreasing=TRUE),]
```
```{r}
# Make a box-plot (see above tables for eco zone codes (zcode))
cols=c(
  "snow3",
  rep("lightsteelblue", 2),
  rep("springgreen3", 3),
  "olivedrab",
  rep("gold",3),
  rep("tomato2",4))
par(xaxs="i")
par(fig=c(0.075,0.495,0.52,0.97))
par(mar=c(2,3,2,0))
boxplot(nppEffectL~zcode, data=ecozData, range=0,boxwex=0.5, col=cols,boxlty=0,
ylim=c(0,1),medcol="black", whisklty=1,whiskcol=cols,staplecol=cols,
medlwd=0.7, yaxt="n")
k = length(meansNPPEF$nppEffectL)
points(1:k, meansNPPEF$nppEffectL, col = "black", pch=19, cex=0.30)
axis(side=2, at=c(0,0.2,0.4,0.6,0.8,1), las=2, tck=-0.03)
abline(h=0.5)
mtext(side=3, "Limiting effect of NPP")
par(fig=c(0.505,0.925,0.52,0.97), new=T)
par(mar=c(2,0,2,3))
boxplot(bioEffectL~zcode, data=ecozData, range=0,boxwex=0.5, col=cols,boxlty=0,
ylim=c(0,1), medcol="black", whisklty=1,whiskcol=cols,staplecol=cols,
medlwd=0.7, yaxt="n")
points(1:k, meansBIOEF$bioEffectL, col = "black", pch=19, cex=0.30)
axis(side=4, at=c(0,0.2,0.4,0.6,0.8,1), las=2, tck=-0.03)
mtext(side=3, "Limiting effect of biodiversity")
abline(h=0.5)
par(fig=c(0.075,0.495,0.02,0.47), new=T)
par(mar=c(2,3,2,0))
boxplot(patEffectL~zcode, data=ecozData, range=0,boxwex=0.5, col=cols,boxlty=0,
ylim=c(0,1), medcol="black", whisklty=1,whiskcol=cols,staplecol=cols,
medlwd=0.7, yaxt="n")
points(1:k, meansPATEF$patEffectL, col = "black", pch=19, cex=0.30)
axis(side=2, at=c(0,0.2,0.4,0.6,0.8,1), las=2, tck=-0.03)
mtext(side=3, "Limiting effect of pathogens")
abline(h=0.5)
par(fig=c(0.505,0.925,0.02,0.47), new=T)
par(mar=c(2,0,2,3))
boxplot(ldensity~zcode, data=ecozData, range=0,boxwex=0.5, col=cols,boxlty=0,
medcol="black", whisklty=1,whiskcol=cols,staplecol=cols,medlwd=0.7, yaxt="n")
points(1:k, means$ldensity, col = "black", pch=19, cex=0.30)
axis(side=4, at=c(-2,-1,0,1,2,3,4), las=2, tck=-0.03)
mtext(side=3, "ln(Population density)")
```
# References
 - Binford, Lewis R. 2001. Constructing Frames of Reference: An Analytical Method for Archaeological Theory
   Building Using Ethnographic and Environmental Data Sets. Berkeley: University of California Press.
 - Cashdan, Elizabeth. 2014. “Biogeography of Human Infectious Diseases: A Global Historical Analysis.”
   Edited by Linda Anne Selvey. PLoS ONE 9 (10): e106752. doi:10.1371/journal.pone.0106752.
 - Ellis, Erle C., Erica C. Antill, and Holger Kreft. 2012. “All Is Not Loss: Plant Biodiversity in the
   Anthropocene.” PLOS ONE 7 (1): e30535. doi:10.1371/journal.pone.0030535.
 - Kelly, Robert L. 2013. The Lifeways of Hunter-Gatherers: The Foraging Spectrum. 2 edition. Cambridge:
   Cambridge University Press.
 - Kreft, Holger, and Walter Jetz. 2007. “Global Patterns and Determinants of Vascular Plant Diversity.”
   Proceedings of the National Academy of Sciences 104 (14): 5925–30. doi:10.1073/pnas.0608361104.
 - Lieth, Helmut. 1973. “Primary Production: Terrestrial Ecosystems.” Human Ecology 1 (4): 303–32.
   doi:10.1007/BF01536729.
 - Low, Bobbi S. 1994. “Pathogen Intensity Cross-Culturally.” World Cultures 8 (1): 24–34.
 - Salonen, J Sakari, Adrian J Verster, Stefan Engels, Janne Soininen, Mathias Trachsel, and Miska Luoto. 2016.
   “Calibrating Aquatic Microfossil Proxies with Regression-Tree Ensembles: Cross-Validation with Modern
   Chironomid and Diatom Data.” The Holocene 26 (7): 1040–8. doi:10.1177/0959683616632881.
 - Dinerstein, Eric & Olson, David & Joshi, Anup & Vynne, Carly & Burgess, Neil D. & Wikramanayake, Eric &
   Hahn, Nathan et al. 2017. “An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm”.
   BioScience. Oxford Academic 67(6). 534–545. (doi:10.1093/biosci/bix014)
