/*!
Model Description
=================

This model description follows the ODD (Overview, Design concept, Details)
protocol (Grimm et al., 2006; Grimm et al., 2010). The model description follows
the idea of literate programming (Knuth 1992) to the extent useful in Rust
source code – the actual model is generated from this file that documents the
model, but the source code is largely commented using natural-language
descriptions, not generated from them (as would be the case in a literal
program).

# 1. Purpose

The dispersal model generates a deep phylogeny of hunter-gatherer cultures based
on culture-mediated cooperation and resource-driven migration. It is a
demographic migration model in which the areal distribution of languages is an
emergent property, not an imposed structure. The model is designed with
extension to more concrete research questions in mind. In the current, first
stage, the purpose of the model is to investigate how languages disperse and
split, driven only by the necessary interactions between humans.

The summary statistics of this phylogeny (in particular diversification
rates) are to be compared to values known from language evolution. The model
is structured to be easily applied to study the history of the settlement of
the Americas at a later time. It would requires paleoclimate data to produce
results that can be compared to that history.
*/

// Load useful modules
use rand::prelude::*;
use rand_distr::Normal;
use rayon::prelude::*;
use std::collections::HashMap;

mod debug;
mod ecology;
mod hexgrid;

use std::f64::consts::PI;

/**

# 2. Entities, state variables, and scales

The model consists of agents interacting on a hexagonal discrete global grid in
discrete time. One time step is supposed to model a season with a duration of
half a year.
 */

type HalfYears = u32;

/**
Whereever possible, resources are measured in kcal (in SI units: 1 kcal = 4.184 kJ)
 */

type KCal = f32;

/**
## 2.1 Families

The main decision-making agents of the simulation are families. Families can
migrate between cells and form links to other families in the context of
cooperation to extract resources.
 */
struct Family {
    /// The agent's history of decendence, also serving as unique ID.
    descendence: String,
    /// The effective size of the family in number of adults. One adult is
    /// assumed to consume the same amount of food/energy and to contribute the
    /// same labor to foraging as any other adult.
    effective_size: usize,
    /// The family's shared culture.
    culture: Culture,
    /// The current location of the agent.
    location: hexgrid::Index,
    /// The previous locations of the agent. This is useful for some bits of
    /// analysis, but agents are also guaranteed to have knowledge about their
    /// recent locations within range, where other knowledge depends on random
    /// factors.
    location_history: Vec<hexgrid::Index>,
    /// The amount of stored resources, in kcal, the family has access to.
    stored_resources: KCal,

    /// The number of seasons to wait until the next child (reset to 2 when
    /// starvation happens)
    seasons_till_next_child: HalfYears,
    /// For bookkeeping purposes (eg. generating descendant's ‘descendence’
    /// values), keep track of the number of offspring families this family has
    /// spawned so far.
    number_offspring: u16,
    /// A bookkeeping quantity. Instead of mutation happening in each time step
    /// with a tiny probability, the same distribution of times between
    /// mutations is generated by drawing a number of season from a geometric
    /// distribution and counting it down by one each time step, which is useful
    /// because random number generation is computationally expensive.
    seasons_till_next_mutation: HalfYears,
}
impl PartialEq for Family {
    fn eq(&self, other: &Self) -> bool {
        self.descendence == other.descendence
    }
}

/**
Families in the same location with compatible cultures can cooperate to improve
their chances at extracting resources. (Following XXX, cooperation could also
mean sharing resources between different families. To simplify the model, this
implementation does not contain that effect.) The cooperative # groups formed by
cooperating families are higher-level agents created ad-hoc in each time step.
They do not persist or have effect beyond a single time step. Resource
exploitation happens at the level of the cooperative group and is distributed
to the individual families after the fact.
 */

/**
## 2.2 Cultures

Every family has a culture. These are very abstract and vastly simplified, due
to the lack of quantitative data on cultural evolution in a framework comparable
to the one used for this study. Based on the need to have a data structure that
supports random drift, a low but positive chance of back-mutation, and a large
number of equally similar cultures, we describe culture using a binary vector.
Computers make natural use of the binary representation integer numbers, so a
binary vector is equivalent to an unsigned integer of sufficient size, which is
faster to use in computations and more efficient to store.
 */
type Culture = u32;

/**
## 2.3 Grid and Patches

The geography of the simulation is described by a hexagonal equal-area discrete
global grid. The grid logic is implemented in Uber's H3 library (XXX) and
exposed to the simulation by the `hexgrid` module. Each individual grid cell
contains exactly one patch. Each of these patches has a maximum and current
availability of resources, measured in kcal available over the course of half a
year. In the current state of the model, the resource maximum is constant
throughout the simulation, but future work might add seasonality (with every
other time step corresponding to the more plentiful half of the year and the
others to the scarcer half). By nature, the simulation invites the extension to
include paleoclimate data, but that only becomes relevant once it shows
fundamentally reasonable dynamics.
 */
struct Patch {
    /// The resources currently available (not necessarily accessible, see XXX)
    /// in this patch, in kcal / season.
    resources: KCal,
    /// The maximum possible resources available in a time step, also in kcal /
    /// season.
    max_resources: KCal,
}

/**
## 2.4 State

The associations between gridcells and patches and between gridcells and the
families located there (stored in the Family's `location`) are the core of the
model state. The state also tracks the time, measured in time steps
corresponding to half a year each, since the start of the simulation, and stores
a copy of the model parameters.
 */
struct State {
    /// The patches of the model, indexed by their address according to the H3
    /// discrete global grid system. This set is fixed, although the properties
    /// of the patches may change with time.
    patches: HashMap<hexgrid::Index, Patch>,
    /// The agents (families) currently active in the simulation. This vector
    /// changes over time as new families are added and old families die out.
    families: Vec<Family>,
    /// The current time step, in half years since start of the simulation.
    t: HalfYears,
}

/**
# 3. Process overview and scheduling

The model progresses in discrete time steps, each corresponding to half a year
of simulated time. The entire simulation consists of repeating the step to
simulate 15000 years. The structure of a single time step consist of two parts,
as follows.
 */
fn step(families: &mut Vec<Family>, patches: &mut HashMap<hexgrid::Index, Patch>, p: &Parameters) {
    let mut families_by_location = step_part_1(families, patches, p);
    step_part_2(&mut families_by_location, patches, p);
}

/**
The first part focuses on the individual families, which shrink, grow, die,
split, and move. It returns the list of families at the end of the season,
grouped by their location after potential moves. Because the movement of a
family depends on the distribution of othe families at he start of the season
(which might be changed in the future), it can happen entirely in parallel.
*/
fn step_part_1(
    families: &mut Vec<Family>,
    patches: &HashMap<hexgrid::Index, Patch>,
    p: &Parameters,
) -> HashMap<hexgrid::Index, Vec<Family>> {
    let mut families_by_location: HashMap<hexgrid::Index, Vec<Family>> = HashMap::new();
    //TODO In python, I could follow the updates on the culture distribution
    // live while updating the Families using `decide_on_moving`. This proved to
    // be insanely difficult in Rust, so I gave it up. How could it be done? How
    // big of a difference does it make, given that it leads to suboptimal
    // choices of the agents? How could it be done in Rust?
    let cultures_by_location = by_location(families);

    //TODO: With the current `cultures_by_location` version of the code, it
    // doesn't matter in which order these agents are updated, but either we
    // need to change that, or we need to find some way that a slightly nicer
    // neighboring patch does not attract a vast amount of people, much more
    // than it can support. I mean, suboptimal choices are part of the game, but
    // how bad should they be? In the latter case, remove this shuffling, which
    // is unnecessary und expensive.
    let mut rng = rand::thread_rng();
    families.shuffle(&mut rng);

    for mut family in families.drain(..) {
        use_resources_and_maybe_shrink(&mut family, p);
        if is_moribund(&family) {
            continue;
        }

        maybe_grow(&mut family);

        let nearby = hexgrid::nearby_locations(family.location);

        match maybe_procreate(&mut family) {
            None => {}
            Some(descendant) => {
                let observed = observe_neighbors(
                    &descendant,
                    patches,
                    &cultures_by_location,
                    &nearby,
                    p.attention_probability,
                );
                // In terms of scheduling a new family can (and if possible
                // should) move immediately when created. This behaviour is
                // taken from del Castillo (2013). Also, a descendant family
                // will move directly before their progenitor.

                let destination = decide_on_moving(&descendant, observed, true, p);
                families_by_location
                    .entry(destination.unwrap_or(family.location))
                    .or_insert(vec![])
                    .push(descendant);
            }
        }
        let observed = observe_neighbors(
            &family,
            patches,
            &cultures_by_location,
            &nearby,
            p.attention_probability,
        );
        let destination = decide_on_moving(&family, observed, false, p);
        families_by_location
            .entry(destination.unwrap_or(family.location))
            .or_insert(vec![])
            .push(family);
    }
    families_by_location
}

/**
The second part focusses on the patches. The resources of a patch are updated
according to the families exploiting them over the season. This is described in
detail in Submodule 7.5. Everything here happens locally to a patch, with no
external interaction, so this can be done in parallel. After exploitation,
patches recover advance to the next season according to Submodule 7.6. This
concludes a time step.
 */
fn step_part_2(
    families_by_location: &mut HashMap<hexgrid::Index, Vec<Family>>,
    patches: &mut HashMap<hexgrid::Index, Patch>,
    p: &Parameters,
) {
    for (patch_id, families) in families_by_location {
        let mut patch = patches.entry(*patch_id).or_insert(Patch {
            // TODO Should we actually panic in this case? After all, some
            // family moved to a patch that doesn't exist, how did they even
            // find it?
            resources: 0.0,
            max_resources: 0.0,
        });
        let mut resource_reduction: KCal = 0.0;
        let (cooperatives, sum_labor) = cooperate(families.iter_mut().collect());

        for cooperating_families in cooperatives {
            resource_reduction += extract_resources(&mut patch, cooperating_families, sum_labor, p);
        }

        exploit(&mut patch, resource_reduction);
    }

    for mut patch in patches.values_mut() {
        recover(&mut patch, p.resource_recovery);
    }
}

/**
# 4. Design concepts

Under the ODD protocol, the design principles largely fall into questions. Where
my answer indicates an invariant property of the simulation, I provide a test
function that checks that invariance if possible.

 */
mod concepts {}

/**
## 4.1 Basic priciples

### Which general concepts, theories, hypotheses, or modeling approaches are underlying the model’s design?

According to its purpose of providing a model for language dispersal and split,
our model draws on existing publications looking at for cultures changing in
time and space, focussing on taking a bottom-up approach on languages splitting.
A major useful reference is the PSMED model (delcastillo2013modeling,
barcelo2013psmed, barcelo2015simulating), which includes two drivers of cultural
change in the agents: Drift and assimilation. In isolation, agents' cultures
undergo drift. Where social interactions happen, drift is counterbalanced by
cultural assimilation for agents that cooperate with each other. In the case of
that model, agents interact with other agents in a limited range and based on
need. We posit a similar basic *relationship between cooperation driving
cultural assimilation, and cultural similarity conditioning cooperation*. Due to
the larger scope of our model, however, we avoid tracking networks of pairwise
interactions and instead assume that cooperation happens in patches,
unconditionally between all individuals of compatible culture in that patch.

This interaction between cooperation and culture is the main addition to an
otherwise demographic dispersal model. A major necessary feature of the
dispersal component for the culture component is to allow group fission and
fusion, to allow culture splits to emerge from low-level agent interactions, but
to also drive incentives for agents to congregate, cooperate, and assimilate
their cultures. As such, the model draws heavily on the agent-based model by
crema2014simulation, crema2015modeling, with minor variants.

FIXME: Given that statement, I should really construct an implementation of
Crema's model compatible with my setup, where the differences are explicitly
visible as model parameters that I use differently from them. My patch topology
is different, what else?

One of the deviations from Crema's model, and also from PSMED, is the geography
underlying the simulation. Crema and Barceló use a quadratic grid with arbitrary
fixed or randomly generated resources. A long-term goal for our model it
applicability to real-world language dispersal processes. A hexagonal grid has
some advantages over a quadratic grid on the plane, in that all hexagons within
a fixed number of steps from a focus are a much better approximation of a circle
than all squares within a fixed number of steps from a central square. Hexagons
also have nicer properties for delineating boundaries, which need some
approximation for square grids (cf. kuijper2004detecting, which is not directly
on finding boundaries, but solving that problem nonetheless). On a sphere such
as Earth, using a hexagonal grid has the additional advantage of reducing
distortions. Using hexagonal grids in continental or global dispersal
simulations is well-established (gavin2017processbased, callegari2013agentbased).

Our model is thus an agent-based model of the emergence of cultural areas from
fission-fusion dynamics, where local cooperation is the main driver to prevent
cultures from unconstrained evolutionary drift.

### How were they taken into account?

### Are they used at the level of submodels, or is their scope the system level?

### Will the model provide insights about the basic principles themselves, i.e., their scope, their usefulness in real-world scenarios, validation, or modification?

### Does the model use new, or previously developed, theory for agent traits from which system dynamics emerge?
 */

/**
 ## 4.2 Emergence
*/
fn similar_culture(c1: &Culture, c2: &Culture) -> bool {
    // FIXME wasn't there a parameter for this?
    (c1 ^ c2).count_ones() < 6
}

fn cooperate<'a>(
    families_in_this_location: Vec<&'a mut Family>,
) -> (Vec<Vec<&'a mut Family>>, usize) {
    let mut sum_labor: usize = 0;
    let mut groups: Vec<Vec<&mut Family>> = vec![];
    for family in families_in_this_location {
        sum_labor += family.effective_size;
        let mut joined_group: Option<&mut Vec<&mut Family>> = None;
        for group in groups.iter_mut() {
            let mut join = true;
            for other_family in group.iter() {
                if !similar_culture(&family.culture, &other_family.culture) {
                    join = false;
                    break;
                }
            }
            if join {
                joined_group = Some(group);
                break;
            }
        }
        match joined_group {
            None => {
                groups.push(vec![family]);
            }
            Some(group) => {
                group.push(family);
            }
        }
    }
    (groups, sum_labor)
}

struct Parameters {
    attention_probability: f32,
    time_step_energy_use: KCal,
    storage_loss: f32,
    resource_recovery: f32,
    culture_mutation_rate: f64,
    culture_dimensionality: u8,
    cooperation_gain: f32,
    accessible_resources: f32,
    evidence_needed: f32,

    boundary_west: f64,
    boundary_east: f64,
    boundary_south: f64,
    boundary_north: f64,
}

fn known_location(
    history: &Vec<hexgrid::Index>,
    nearby: &Vec<hexgrid::Index>,
    attention_probability: f32,
) -> Vec<hexgrid::Index> {
    let mut result = vec![];
    for location in nearby {
        if history[0..min(8, history.len())].contains(&location) {
            result.push(*location);
            continue;
        }
        if attention(attention_probability) {
            result.push(*location);
            continue;
        }
    }
    result
}

fn attention(attention_probability: f32) -> bool {
    random::<f32>() < attention_probability
}

fn scout<'a>(
    location: hexgrid::Index,
    reference_culture: Culture,
    patches: &'a HashMap<hexgrid::Index, Patch>,
    cultures_by_location: &HashMap<hexgrid::Index, HashMap<Culture, usize>>,
) -> Option<(hexgrid::Index, &'a Patch, usize, usize)> {
    let cultures = match cultures_by_location.get(&location) {
        None => return Some((location, patches.get(&location)?, 0, 0)),
        Some(c) => c,
    };
    let mut cooper: usize = 0;
    let mut compet: usize = 0;
    for (culture, count) in cultures {
        if similar_culture(&reference_culture, culture) {
            cooper += count;
        } else {
            compet += count;
        }
    }
    Some((location, patches.get(&location)?, cooper, compet))
}

fn observe_neighbors<'a>(
    family: &'a Family,
    patches: &'a HashMap<hexgrid::Index, Patch>,
    cultures_by_location: &HashMap<hexgrid::Index, HashMap<Culture, usize>>,
    neighbors: &Vec<hexgrid::Index>,
    attention_probability: f32,
) -> Vec<(hexgrid::Index, &'a Patch, usize, usize)> {
    let mut result: Vec<(hexgrid::Index, &'a Patch, usize, usize)> = vec![];
    match scout(
        family.location,
        family.culture,
        patches,
        cultures_by_location,
    ) {
        None => {}
        Some((location, patch, cooperators, competitors)) => {
            result.push((location, patch, cooperators, competitors))
        }
    }
    for location in known_location(&family.location_history, neighbors, attention_probability) {
        if location == family.location {
            continue;
        }
        match scout(location, family.culture, patches, cultures_by_location) {
            None => {}
            Some((location, patch, cooperators, competitors)) => {
                result.push((location, patch, cooperators, competitors));
            }
        }
    }
    result
}

fn initialization(precipitation: &Vec<u16>, width: usize, p: &Parameters) -> Option<State> {
    let start1: hexgrid::Index = hexgrid::closest_grid_point(-159.873, 65.613)?;
    let start2: hexgrid::Index = hexgrid::closest_grid_point(-158.2718, 60.8071)?;

    let area: f32 = libh3::hex_area_km_2(5) as f32;

    let mut patches: HashMap<hexgrid::Index, Option<Patch>> = HashMap::new();
    let mut new_patches: std::collections::BinaryHeap<hexgrid::Index> =
        std::collections::BinaryHeap::new();
    new_patches.push(start1);
    new_patches.push(start2);
    loop {
        let next = match new_patches.pop() {
            None => break,
            Some(n) => n,
        };
        if patches.contains_key(&next) {
            continue;
        }
        let geo = hexgrid::geo_coordinates(next);
        let latitude = geo.lat * 180. / PI;
        let longitude = geo.lon * 180. / PI;
        if p.boundary_west < longitude
            && longitude < p.boundary_east
            && p.boundary_south < latitude
            && latitude < p.boundary_north
        {
            let patch = ecology::patch_from_coordinates(geo, precipitation, width);
            match patch {
                None => {
                    patches.insert(next, None);
                    continue;
                }
                Some(resources) => {
                    patches.insert(
                        next,
                        Some(Patch {
                            resources: resources * p.time_step_energy_use * area,
                            max_resources: resources * p.time_step_energy_use * area,
                        }),
                    );
                }
            };
            for q in hexgrid::nearby_locations(next) {
                if patches.contains_key(&q) {
                    continue;
                }
                new_patches.push(q);
            }
        } else {
            patches.insert(next, None);
        }
    }
    let f1 = Family {
        descendence: String::from("A"),
        location: start1,
        location_history: vec![],
        seasons_till_next_child: 4,
        culture: 0b000_000_000_000_000,

        effective_size: 2,
        number_offspring: 0,
        seasons_till_next_mutation: 0, // FIXME: Don't mutate immediately
        stored_resources: 1_600_000.,
    };
    let f2 = Family {
        descendence: String::from("F"),
        location: start2,
        location_history: vec![],
        seasons_till_next_child: 4,
        culture: 0b111_111_111_111_111,

        effective_size: 2,
        number_offspring: 0,
        seasons_till_next_mutation: 0, // FIXME: Don't mutate immediately
        stored_resources: 1_600_000.,
    };
    // let families: HashMap<hexgrid::Index, Vec<Family>> = HashMap::new();
    // families.insert(start1, vec![f1]);
    // families.insert(start2, vec![f2]);
    Some(State {
        patches: patches
            .drain()
            .filter_map(|(i, p)| match p {
                None => None,
                Some(q) => Some((i, q)),
            })
            .collect(),
        families: vec![f1, f2],
        t: 0,
    })
}

fn use_resources_and_maybe_shrink(family: &mut Family, p: &Parameters) {
    let resources = family.stored_resources;
    let mut size = family.effective_size;
    while resources_at_season_end(resources, size, p) < 0. && size > 0 {
        size -= 1;
        family.seasons_till_next_child = max(family.seasons_till_next_child, 2)
    }
    family.effective_size = size;
    family.stored_resources = resources_at_season_end(family.stored_resources, size, p);
}

fn resources_at_season_end(resources: KCal, size: usize, p: &Parameters) -> KCal {
    let mut resources_after: KCal = resources - (size as f32) * p.time_step_energy_use;
    if resources_after > 0. {
        resources_after *= 1. - p.storage_loss;
    }
    resources_after
}

fn is_moribund(family: &Family) -> bool {
    family.effective_size < 2
}

fn maybe_grow(family: &mut Family) {
    if family.seasons_till_next_child == 0 {
        family.effective_size += 1;
        family.seasons_till_next_child = 2;
    } else {
        family.seasons_till_next_child -= 1;
    }
}

fn maybe_procreate(family: &mut Family) -> Option<Family> {
    if family.effective_size < 10 {
        None
    } else {
        family.number_offspring += 1;
        family.effective_size -= 2;
        Some(Family {
            descendence: format!("{}:{:}", family.descendence, family.number_offspring),
            location: family.location,
            location_history: vec![],
            seasons_till_next_child: 12 * 2,
            culture: family.culture,

            effective_size: 2,
            number_offspring: 0,
            seasons_till_next_mutation: 0, // FIXME: Don't mutate immediately
            stored_resources: 0.,
        })
    }
}

#[test]
fn test_decide_on_moving() {
    let patch1 = Patch {
        resources: 10.,
        max_resources: 10.,
    };
    let patch2 = Patch {
        resources: 100.,
        max_resources: 100.,
    };
    let _patch3 = Patch {
        resources: 100000.,
        max_resources: 100000.,
    };
    let mini_param = Parameters {
        attention_probability: 0.1,
        time_step_energy_use: 10.,
        storage_loss: 0.25,
        resource_recovery: 0.20,
        culture_mutation_rate: 6e-3,
        culture_dimensionality: 20,
        cooperation_gain: 0.0,
        accessible_resources: 1.0,
        evidence_needed: 0.3,

        // Some part of Western Alaska
        boundary_west: -168.571541,
        boundary_east: -148.571541,
        boundary_south: 56.028198,
        boundary_north: 74.52671,
    };

    let mini_family = Family {
        culture: 0,
        descendence: String::from(""),
        effective_size: 2,
        location: 0,
        location_history: vec![1],
        number_offspring: 0,
        seasons_till_next_child: 0,
        seasons_till_next_mutation: 0,
        stored_resources: 1.,
    };
    assert_eq!(
        decide_on_moving(
            &mini_family,
            vec![(1, &patch1, mini_family.effective_size, 0)],
            false,
            &mini_param
        ),
        Some(1)
    );

    assert_eq!(
        decide_on_moving(
            &mini_family,
            vec![
                (1, &patch1, mini_family.effective_size, 0),
                (2, &patch2, mini_family.effective_size, 0)
            ],
            true,
            &mini_param
        ),
        Some(2)
    );

    assert_eq!(
        decide_on_moving(
            &mini_family,
            vec![
                (1, &patch1, mini_family.effective_size, 0),
                (2, &patch2, mini_family.effective_size, 0)
            ],
            false,
            &mini_param
        ),
        Some(2)
    );
}

#[test]
fn test_decide_on_moving_is_uniform() {
    let patch1 = Patch {
        resources: 10.,
        max_resources: 10.,
    };
    let patch2 = Patch {
        resources: 100.,
        max_resources: 100.,
    };
    let patch3 = Patch {
        resources: 100000.,
        max_resources: 100000.,
    };
    let mini_param = Parameters {
        attention_probability: 0.1,
        time_step_energy_use: 10.,
        storage_loss: 0.25,
        resource_recovery: 0.20,
        culture_mutation_rate: 6e-3,
        culture_dimensionality: 20,
        cooperation_gain: 0.0,
        accessible_resources: 1.0,
        evidence_needed: 0.3,

        // Some part of Western Alaska
        boundary_west: -168.571541,
        boundary_east: -148.571541,
        boundary_south: 56.028198,
        boundary_north: 74.52671,
    };

    let mini_family = Family {
        culture: 0,
        descendence: String::from(""),
        effective_size: 2,
        location: 0,
        location_history: vec![1],
        number_offspring: 0,
        seasons_till_next_child: 0,
        seasons_till_next_mutation: 0,
        stored_resources: 1.,
    };

    let mut c = [0, 0, 0, 0, 0];
    for _ in 1..300 {
        let k = decide_on_moving(
            &mini_family,
            vec![
                (1, &patch1, mini_family.effective_size, 0),
                (2, &patch3, mini_family.effective_size, 0),
                (3, &patch2, mini_family.effective_size, 0),
                (4, &patch2, mini_family.effective_size, 0),
            ],
            false,
            &mini_param,
        );
        c[match k {
            None => 0,
            Some(k) => k as usize,
        }] += 1;
    }
    assert_eq!(c[0], 0);
    assert_eq!(c[1], 0);
    assert!((c[2] - 100i8).abs() < 15);
    assert!((c[3] - 100i8).abs() < 15);
    assert!((c[4] - 100i8).abs() < 15);
}

fn decide_on_moving<'a>(
    family: &'a Family,
    known_destinations: Vec<(hexgrid::Index, &Patch, usize, usize)>,
    avoid_stay: bool,
    p: &Parameters,
) -> Option<hexgrid::Index> {
    let mut kd = known_destinations.iter();
    let (mut target, mut patch, mut cooperators, mut competitors): (
        hexgrid::Index,
        &Patch,
        usize,
        usize,
    );
    match kd.next() {
        None => return None,
        Some((t, p, cooper, compet)) => {
            target = *t;
            patch = p;
            cooperators = *cooper;
            competitors = *compet;
        }
    };
    if avoid_stay {
        match kd.next() {
            None => return None,
            Some((t, p, cooper, compet)) => {
                target = *t;
                patch = p;
                cooperators = *cooper;
                competitors = *compet;
            }
        }
    }
    let mut max_gain: KCal = resources_from_patch(patch, cooperators, competitors, true, p)
        * family.effective_size as f32
        / cooperators as f32;
    let current_gain = if avoid_stay { 0. } else { max_gain };
    let mut c = 0.;
    for (coords, patch, cooperators, competitors) in kd {
        let expected_gain = resources_from_patch(
            patch,
            family.effective_size + *cooperators,
            *competitors,
            true,
            p,
        ) * (family.effective_size as f32
            / (family.effective_size + *cooperators) as f32);
        if expected_gain >= max_gain {
            if expected_gain < current_gain + p.time_step_energy_use * p.evidence_needed {
                continue;
            }
            if (expected_gain - max_gain).abs() < std::f32::EPSILON {
                c += 1.;
                if random::<f32>() < c / (1. + c) {
                    continue;
                }
            }
            target = *coords;
            max_gain = expected_gain;
        }
    }
    Some(target)
}

fn extract_resources(
    patch: &mut Patch,
    group: Vec<&mut Family>,
    total_labor_here: usize,
    p: &Parameters,
) -> KCal {
    let labor: usize = group.iter().map(|f| f.effective_size as usize).sum();
    let resources_extracted =
        resources_from_patch(&patch, labor, total_labor_here - labor, false, &p);
    let mut group_copy: Vec<&mut Family> = vec![];
    for family in group {
        family.stored_resources +=
            resources_extracted * family.effective_size as f32 / labor as f32;
        group_copy.push(family);
    }
    adjust_culture(group_copy, p);
    resources_extracted
}

#[test]
fn test_resources_from_patch() {
    let patch1 = Patch {
        resources: 10.,
        max_resources: 10.,
    };
    let patch2 = Patch {
        resources: 100.,
        max_resources: 100.,
    };
    let patch3 = Patch {
        resources: 100000.,
        max_resources: 100000.,
    };
    let mut mini_param = Parameters {
        attention_probability: 0.1,
        time_step_energy_use: 10.,
        storage_loss: 0.25,
        resource_recovery: 0.20,
        culture_mutation_rate: 6e-3,
        culture_dimensionality: 20,
        cooperation_gain: 0.0,
        accessible_resources: 1.0,
        evidence_needed: 0.3,

        // Some part of Western Alaska
        boundary_west: -168.571541,
        boundary_east: -148.571541,
        boundary_south: 56.028198,
        boundary_north: 74.52671,
    };
    assert_eq!(resources_from_patch(&patch1, 2, 0, true, &mini_param), 10.);
    assert_eq!(resources_from_patch(&patch2, 2, 0, true, &mini_param), 22.);
    assert_eq!(resources_from_patch(&patch3, 2, 0, true, &mini_param), 22.);
    assert!((resources_from_patch(&patch2, 3, 7, true, &mini_param) - 30.).abs() < 0.001);
    mini_param.cooperation_gain = 0.5;
    assert!((resources_from_patch(&patch3, 25, 0, true, &mini_param) - 1.5 * 25. * 10.).abs() < 5.);
}

fn resources_from_patch(
    patch: &Patch,
    labor: usize,
    others_labor: usize,
    estimate: bool,
    p: &Parameters,
) -> KCal {
    let mut my_relative_returns: f32 = p.time_step_energy_use
        * labor as f32
        * effective_labor_through_cooperation(labor, p.cooperation_gain);
    let mut rng = rand::thread_rng();
    if !estimate {
        let dist = Normal::new(
            my_relative_returns,
            p.time_step_energy_use / (labor as f32).powf(0.5),
        );
        match dist {
            Err(_) => {}
            Ok(d) => {
                my_relative_returns = d.sample(&mut rng);
                my_relative_returns = max(0., my_relative_returns)
            }
        }
    }
    let mut others_relative_returns: f32 = 0.;
    if others_labor > 0 {
        others_relative_returns = p.time_step_energy_use
            * others_labor as f32
            * effective_labor_through_cooperation(labor, p.cooperation_gain);
        if !estimate {
            let dist = Normal::new(
                my_relative_returns,
                p.time_step_energy_use / (labor as f32).powf(0.5),
            );
            match dist {
                Err(_) => {}
                Ok(d) => {
                    others_relative_returns = d.sample(&mut rng);
                    others_relative_returns = max(0., others_relative_returns)
                }
            }
        }
    }
    my_relative_returns / (my_relative_returns + others_relative_returns)
        * min(
            my_relative_returns + others_relative_returns,
            patch.resources * p.accessible_resources,
        )
}

fn effective_labor_through_cooperation(n_cooperators: usize, cooperation_gain: f32) -> f32 {
    1. + (n_cooperators as f32 - 1.).powf(cooperation_gain) / 10.
}

fn adjust_culture(mut cooperating_families: Vec<&mut Family>, p: &Parameters) {
    for f in &mut cooperating_families {
        mutate_culture(f, p);
    }
    let family: Option<&&mut Family> = cooperating_families.choose(&mut rand::thread_rng());
    match family {
        None => {}
        Some(f) => {
            let target: Culture = f.culture;
            for f2 in cooperating_families {
                f2.culture = target;
            }
        }
    }
}

fn mutate_culture(family: &mut Family, p: &Parameters) {
    if family.seasons_till_next_mutation > 0 {
        family.seasons_till_next_mutation -= 1;
    }
    if family.seasons_till_next_mutation == 0 {
        let i: u8 = rand::thread_rng().gen_range(0, p.culture_dimensionality);
        family.culture ^= 1 << i;
        family.seasons_till_next_mutation =
            random::<f64>().log(1. - p.culture_mutation_rate) as u32;
    }
}

fn exploit(patch: &mut Patch, resource_reduction: KCal) {
    patch.resources -= resource_reduction;
    //FIXME why does this keep happening?
    // assert!(patch.resources > 0.);
}

fn recover(patch: &mut Patch, resource_recovery: f32) {
    if patch.resources < patch.max_resources - 1. {
        patch.resources +=
            patch.resources * resource_recovery * (1. - patch.resources / patch.max_resources);
    }
}

fn min<T: PartialOrd>(a: T, b: T) -> T {
    if a < b {
        a
    } else {
        b
    }
}
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if b < a {
        a
    } else {
        b
    }
}

fn main() {
    run();
}

fn run() -> Option<()> {
    let mut parser = argparse::ArgumentParser::new();
    parser.set_description("Run a dispersal simulation");
    let p = Parameters {
        attention_probability: 0.1,
        time_step_energy_use: 2263. as KCal * 365.242_2 / 2.,
        storage_loss: 0.33,
        resource_recovery: 0.20,
        culture_mutation_rate: 6e-3,
        culture_dimensionality: 20,
        cooperation_gain: 0.5,
        accessible_resources: 0.2,
        evidence_needed: 0.3,

        boundary_west: -168.571_541,
        boundary_east: -34.535_395,
        boundary_south: -56.028_198,
        boundary_north: 74.52671,
    };

    println!("# Initialization ...");
    // FIXME: There is something messed up in lat/long -> image pixels. It works
    // currently, but the names point towards a deep issue with the layout of
    // the tiff in memory or similar.
    let (vec, width) = ecology::load_precipitation_tif()?;
    let mut s: State = initialization(&vec, width as usize, &p)?;

    loop {
        let mut families_by_location = step_part_1(&mut s.families, &s.patches, &p);
        println!(
            "{:?}",
            families_by_location
                .iter()
                .map(|(k, v)| {
                    let g = hexgrid::geo_coordinates(*k);
                    (g.lon, g.lat, v.len())
                })
                .collect::<Vec<(f64, f64, usize)>>()
        );
        step_part_2(&mut families_by_location, &mut s.patches, &p);
        for (location, families) in families_by_location {
            for mut family in families {
                family.location_history.push(family.location);
                family.location = location;
                s.families.push(family);
            }
        }
        println!("{:}", s.families.len());
        if s.families.is_empty() {
            break;
        }
        s.t += 1;
        println!("t={:}", s.t);
    }
    Some(())
}

fn by_location(families: &Vec<Family>) -> HashMap<hexgrid::Index, HashMap<Culture, usize>> {
    let mut cultures_by_location: HashMap<hexgrid::Index, HashMap<Culture, usize>> = HashMap::new();
    for family in families.iter() {
        let cultures = cultures_by_location
            .entry(family.location)
            .or_insert_with(HashMap::new);
        let counter = cultures.entry(family.culture).or_insert(0);
        *counter += family.effective_size;
    }
    cultures_by_location
}
