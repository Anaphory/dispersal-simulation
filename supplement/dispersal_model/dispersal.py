#!/usr/bin/env python
# cython: language_level=3

"""dispersal

Model the settlement of the Americas using an agent-based model on a hex grid
with resource depletion, migration, and culture-dependent cooperation.
"""


# General imports, which in Python should come on top of the module to make
# dependencies transparent.
import sys        # Writing to standard output as a console program
import json       # Transparent data storage in Java Script Object Notation
import random     # random number generator
import itertools  # Tools for iterating over combinations, etc. of sequences
from dataclasses import dataclass, field

import numpy      # Fast maths
import cython     # Faster execution using C

import matplotlib.pyplot as plt

from dispersal_model.util import (
    serialize, get_data, OnDemandDict, density,
    in_random_order_ignoring_location)

import dispersal_model.hexgrid as hexgrid
from dispersal_model.types_and_units import (
    halfyears, kcal, meters,
    List, Mapping, Sequence, Tuple, Iterable, Optional, Iterator,
    Callable, TextIO, Dict, Any, Counter, DefaultDict)
from dispersal_model.similar_culture_benchmark import cultural_distance

if cython.compiled:
    print("# Running compiled Cython version.")

# Model Description
# =================
#
# This model description follows the ODD (Overview, Design concept, Details)
# protocol (Grimm et al., 2006; Grimm et al., 2010). The model description
# follows the idea of literate programming (Knuth 1992) to the extent useful in
# an IPython Notebook â€“ the actual model is generated from this file that
# documents the model, but the source code is largely commented using
# natural-language descriptions, not generated from them (as would be the case
# in a literal program).
#
# # 1. Purpose
#
# The settlement model generates a deep phylogeny of hunter-gatherer cultures
# based on culture-mediated cooperation and resource-driven migration. It is a
# demographic migration model in which the areal distribution of languages is
# an emergent property, not an imposed structure.
#
# The summary statistics of this phylogeny (in particular diversification
# rates) are to be compared to values known from language evolution. The model
# is structured to be easily applied to study the history of the settlement of
# the Americas at a later time. It would requires paleoclimate data to produce
# results that can be compared to that history.
#

# # 2. Entities, state variables, and scales
#
# The main agents of the simulation are families.
@dataclass
class Family:
    """A family group agent

    Families are the decision-making agent in our model. Families can migrate
    between cells and form links to other families in the context of
    cooperation to extract resources.

    """
    descendence: str
    # The agent's history of decendence, also serving as unique ID
    culture: cython.int
    # The family's shared culture
    location_history: List[hexgrid.Index] = field(default_factory=list)
    # A list of cells indices.

    @property
    def location(self) -> hexgrid.Index:
        return self.location_history[0]

    number_offspring: int = 0
    # The number of descendant families this family has given rise to so far
    effective_size: int = 2
    # The effective size of the family in number of adults. One adult is
    # assumed to consume the same amount of food/energy and to contribute the
    # same labor to foraging as any other adult.
    stored_resources: kcal = 0
    # The amount of stored resources, in kcal, the family has access to
    seasons_till_next_child: halfyears = 4
    # The number of seasons to wait until the next child (reset to 2 when
    # starvation happens)

    seasons_till_next_mutation: Optional[halfyears] = None
    # A bookkeeping quantity. Instead of mutation happening in each time step
    # with a tiny probability, the same distribution of times between mutations
    # is generated by drawing a number of season from a geometric distribution
    # and counting it down by one each time step, which is useful because
    # random number generation is computationally expensive.


# Every family has a culture. These are very abstract and vastly simplified,
# due to the lack of quantitative data on cultural evolution in a framework
# comparable to the one used for this study. Based on the need to have a data
# structure that supports random drift, a low but positive chance of
# back-mutation, and a large number of equally similar cultures, we describe
# culture using a binary vector. Computers make natural use of the binary
# representation integer numbers, so a binary vector is equivalent to an `int`,
# and the `int` is faster to use in computations and more efficient to store.

# ! Culture = cython.int

# Families in the same location with compatible cultures can cooperate to
# improve their chances at extracting resources. (Following XXX, cooperation
# could also mean sharing resources between different families. To simplify the
# model, this implementation does not contain that effect.) The cooperative
# groups formed by cooperating families are higher-level agents created ad-hoc
# in each time step. They do not persist or have effect beyond a single time
# step. Resource exploitation happens at the level of the cooperative group and
# is distributed to the individual families after the fact.

# ! CooperativeGroup = List[Family]

# The geography of the simulation is described by a hexagonal equal-area
# discrete global grid. The grid logic is implemented in Uber's H3 library
# (XXX) and exposed to the simulation by the `hexgrid` module. Each individual
# grid cell contains exactly one patch. Each of these patches has a maximum and
# current availability of resources, measured in kcal available over the course
# of half a year. In the current state of the model, the resource maximum is
# constant throughout the simulation, but future work might add seasonality
# (with every other time step corresponding to the more plentiful half of the
# year and the others to the scarcer half). By nature, the simulation invites
# the extension to include palecimate data, but that only becomes relevant once
# it shows fundamentally reasonable dynamics.
@dataclass
class Patch:
    """A patch of land with resources

    Resources can vary through time, up to a fixed maximum
    """
    resources: kcal
    # Resources available available over a period of 6 months
    max_resources: kcal
    # Maximum resources available available over a period of 6 months


# The associations between gridcells and patches and between gridcells and the
# families located there are the core of the model state. The state also tracks
# the time, measured in time steps corresponding to half a year each, since the
# start of the simulation, and stores a copy of the model parameters.
@dataclass
class State:
    """A model state"""
    patches: Mapping[hexgrid.Index, Patch]
    # The grid of resource patches at this time step.
    families: Mapping[hexgrid.Index, List[Family]]
    # A list of families under simulation, by location
    t: halfyears
    # Time steps since simulation start, in 1/2 of a year.


# # 3. Process overview and scheduling
#
# The model progresses in discrete time steps, each corresponding to half a
# year of simulated time. The entire simulation consists of repeating the step
# to simulate 15000 years. The structure of a single time step, which updates
# the State, is as follows.
def step(state: State) -> State:
    """Run a simulation step.

    The individual sub-modules referenced here can be found below.

    """
    # First, families adjust. These things can happen in parallel for families
    # outside interaction range.
    for family in in_random_order_ignoring_location(state.families):
        # Submodule 7.1
        use_resources_and_maybe_shrink(family)
        if is_moribund(family):
            state.families[family.location].remove(family)
            continue

        # Submodule 7.2
        maybe_grow(family)

        # Submodule 7.3
        descendant = maybe_procreate(family)
        if descendant is not None:
            # Migration is handled in Submodule 7.4. In terms of scheduling a
            # new family can (and if possible should) move immediately,
            # immediately before their parent. This behaviour is taken from del
            # Castillo (2013). Also, a descendant family will move *before*
            # their progenitor.
            destination = decide_on_moving(
                descendant,
                current_patch=state.patches[family.location],
                known_destinations=observe_neighbors(
                    family, state.patches, state.families,
                    hexgrid.neighbors_within_distance(
                        family.location,
                        meters(52413))),
                avoid_stay=True)
            movement_bookkeeping(descendant, destination, state)
        # Subsequent earlier moves affect the possible targets of later moves,
        # so scheduling matters and shuffling is important to remove
        # first-mover effects.

        destination = decide_on_moving(
            family,
            current_patch=state.patches[family.location],
            known_destinations=observe_neighbors(
                family, state.patches, state.families,
                hexgrid.neighbors_within_distance(
                    family.location,
                    meters(52413))))
        movement_bookkeeping(family, destination, state)

    # Then, the resources of a patch are updated according to the families
    # exploiting them over the season. This is described in Submodule 7.5.
    # Everything here happens locally to a patch, with no external interaction,
    # so this can be done in parallel.
    for patch_id, families in state.families.items():
        if not families:
            continue
        for family in families:
            assert family.location == patch_id
        patch = state.patches[patch_id]
        resource_reduction = 0.0
        cooperatives, sum_labor = cooperate(families)
        for cooperating_families in cooperatives:
            resource_reduction += extract_resources(
                patch, cooperating_families, sum_labor)
            adjust_culture(cooperating_families)

        exploit(patch, resource_reduction)

    # Then, patches advance to the next season according to Submodule 7.6.
    for patch in state.patches.values():
        recover(patch)

    # At last, the model advances one time step.
    state.t += 1

    # The old state has thus been transformed into the new state.
    return state


# # 4. Design concepts
#
# This model draws heavily on two prior models: (XXX), (XXX).
#
# ## 4.1 Basic priciples
#
#  - Migration happens due to the need to find new resources in marginal
#    evironments
#  - Shared culture mediates cooperation, and cooperation fosters cultural
#    cohesion
#  - Using real(istic) geography provides better insight than abstract
#    environments
#  - The family is generally the basic unit of decision-making and migration in
#    hunter-gatherer societies
#
# ## 4.2 Emergence
def plot_cultural_distance_by_geographical_distance(
        state: State) -> Tuple[Sequence, Sequence]:
    """Plot the cultural distance vs. geographical distance

    We expect that the interplay of migration, cooperation and cultural
    similarity leads to regions of similar cultures with steep geographical
    transition areas to regions containing agents with different culture
    vectors.

    This means that the plot of cultural distances vs. geographical distances
    should therefore show small cultural distances for small geographical
    distances. There should be a critical geographical distance of cohesion
    where the distribution of cultural distances becomes bimodal, with one mode
    being lower than the cooperation threshold and one mode above the
    cooperation threshold. For large geographical distances, the cultural
    distances should be high, but with a big variance.

    """
    cult_dists: List[float] = []
    geo_dists = []
    for (l1, fs1), (l2, fs2) in itertools.combinations_with_replacement(
            state.families.items(), 2):
        geo_dist = hexgrid.geographical_distance(l1, l2)
        for family1, family2 in itertools.product(fs1, fs2):
            cult_dist = cultural_distance(family1.culture, family2.culture)
            geo_dists.append(geo_dist)
            cult_dists.append(cult_dist)
    return geo_dists, cult_dists


# ## 4.3 Adaptation
#
#  - The adaptive behaviour of agents is restricted to their movement, which is
#    implemented to optimize (expected) resource availability in the upcoming
#    time step, given limited knowledge.
#
# ## 4.4 Objectives
#
#  - Agents optimize the expected resources they will be able to gain in the
#    current time step based on the resources available in patches within a
#    certain distance from themselves, and the numbers of cooperating and
#    competing agents in each of those patches. They pick the best patch
#    accordingly if it is better than their current location by at least the
#    amount necessary to provide for one more individual. The procedure is
#    described in detail in [Submodule 7.4](#7.4-Migration)
#
# ## 4.5 Learning
#
#  - Agents are guaranteed to have knowledge of the locations they visited
#    within the previous 2 years, and of all locations within the maximum
#    half-year migration distance that they visited in the previous 4 years.
def known_location(
        family: Family,
        nearby: Iterable[hexgrid.Index]) -> Iterator[hexgrid.Index]:
    """Tell a family which locations nearby they might know about
    """
    # The sub-module that uses this function asserts that the first result of
    # the iterator be the location of the family itself, but the locations can
    # be returned in any order, even in parallel.
    for location in family.location_history[:4]:
        yield location
    for location in nearby:
        if location not in family.location_history[:4]:
            if (location in family.location_history[:8]) or (
                    random.random() < params.attention_probability):
                yield location


# ## 4.6 Prediction
#
#  - Agents use the state of patches they are aware of as proxy for the future
#    state of the system for predicting expected number of resources available
#    to them. Due to scheduling, this means that agents see on average half of
#    the remaining agents in their new positions after moving and half of the
#    remaining agents in their old position before moving. Agents extrapolate
#    their resource availabiltiy from the current state of the system, ie.
#    without taking potential family growth or shrinking into account and
#    without taking into account the movement of other agents that are still in
#    the queue.
# - The exact resources that can be gained from a patch are normally
#    distributed around a mean that depends on the resources available and the
#    families present, with a constant standard deviation per individual.
#    Agents have knowledge of the mean and use it to predict their resource
#    gain, but they do not take the random distribution into account.


# ## 4.7 Sensing
#
# A family can know the current state of some locations (see [Section
# 4.5](#4.5-Learning) in their neighborhood for the decision process whether
# and where to move. That is, for those locations, the family knows actual
# available resources and size and culture vectors of all agents located there
# at the moment.
def observe_neighbors(
        family: Family,
        patches: Mapping[hexgrid.Index, Patch],
        all_families: Mapping[hexgrid.Index, Sequence[Family]],
        neighbors: Iterable[hexgrid.Index]) -> Iterator[
        Tuple[hexgrid.Index, Patch, int, int]]:
    """Summarize what a family know about their surroundings.

    From the sensory data, the family estimates whether agents in patches under
    consideration agents will likely be cooperators (cultural distance less
    than `params.cooperation_threshold`) or competitors.

    """
    for dest in known_location(family, neighbors):
        if patches[dest].max_resources < 1:
            # Don't walk into the water
            continue
        cooperators, competitors = 0, 0
        for f in all_families[dest]:
            if similar_culture(f.culture, family.culture):
                cooperators += f.effective_size
            else:
                competitors += f.effective_size
        yield dest, patches[dest], cooperators, competitors
# The actual split into cooperators and competitors is actualized only by the
# formation of collectives (see [Section 4.9](#4.9-Collectives)) in [Submodule
# 7.5](#7.5-Cooperative-Resource-Extraction)


# ## 4.8 Interaction
#  - Agents compete for limited resources
#  - Agents of similar culture
#    cooperate in the exploitation of resources

def test_similar_culture() -> None:
    """Check the definition of 'similar_culture'

    Test that `similar_culture(x, y)` is exactly a fast implementation of â€˜x
    and y differ in less than `params.cooperation_threshold` entriesâ€™

    """
    if params.cooperation_threshold == 6:
        assert similar_culture(0b000000, 0b110111)
        assert not similar_culture(0b00000000, 0b11111111)
        assert similar_culture(0b01100100, 0b11111111)
        assert not similar_culture(0b00000000000000000000,
                                   0b11111111000000000000)

    # Test systematically. This takes a *loooooong* time.
    for x in range(2**params.culture_dimensionality):
        for y in range(2**params.culture_dimensionality):
            assert (
                similar_culture(x, y) ==
                sum(xi != yi for xi, yi in zip(bin(x), bin(y))
                    ) < params.cooperation_threshold)


#  - Agents may avoid other agents when the expected gain from moving to their
#    spot would be reduced due to their presence (different culture and thus
#    competition instead of cooperation)


# ## 4.9 Collectives
#
def cooperate(families_in_this_location: Sequence[Family]) \
        -> Tuple[Sequence[List[Family]], int]:
    """Form collectives in this location.

    Groups of agents with similar culture on the same patch form temporary
    groups to collaborate for the exploitation of resources, according to this
    grouping structure.

    """
    cooperative_groups: List[List[Family]] = []
    sum_labor = 0
    for family in families_in_this_location:
        sum_labor += family.effective_size
        # Check for all groups already defined in this spot.
        for group in cooperative_groups:
            # If there is any other family in that group
            for other_family in group:
                # who the current family would not cooperate with,
                if not similar_culture(family.culture, other_family.culture):
                    # then ignore that group.
                    break
            else:
                # Otherwise, join a group. This happens when the new family can
                # cooperate with every family already assigned to that group.
                group.append(family)
                break
        else:
            # If there was no group to join, form a new â€˜groupâ€™ consisting just
            # of that family.
            cooperative_groups.append(List[Family]([family]))
    return cooperative_groups, sum_labor
# Cooperatives are then the main agents of resource extraction and cultural
# assimilation, as described in more detail in [Submodule
# 7.5](#7.5-Cooperative-Resource-Extraction).


# ## 4.10 Observation
def observation(
        state: State,
        extensive: TextIO,
        to: TextIO = sys.stdout,
        report_resources: bool = False) -> None:
    """Aggreagte summary statistics from the state.

    Print short summary statistics to a screen log (defaulting to stdout), and
    write a more extensive log to a dedicated logfile.

    Each line in each of the two outputs is a JSON string summarizing some
    properties of the state.

    """
    # Number of families (agents)
    report = {}
    extreport: Dict[str, Any] = {}
    report["t"] = state.t
    report["Number of families"] = sum(
        [len(families) for families in state.families.values()])
    if report["Number of families"] == 0:
        raise StopIteration
    report["Total population count"] = sum(
        [family.effective_size
         for fs in state.families.values()
         for family in fs])
    report["Median stored resources"] = numpy.median(
        [family.stored_resources
         for fs in state.families.values()
         for family in fs])
    extreport["Families"] = [
        (location,
         [(family.descendence, family.effective_size, family.culture)
          for family in families
          if families])
        for location, families in state.families.items()]
    if report_resources:
        extreport["Resources"] = {
            index: patch.resources
            for index, patch in state.patches.items()}

    print(report,
          file=to)
    print(json.dumps(extreport, default=serialize, sort_keys=True),
          file=extensive)


# # 5. Initialization
#
# In addition to describing the initialization, we list the parameters of the
# model here. The sources for the default values are given (FIXME: Or should
# be, once the model is finished).
def patch_from_grid_index(index: hexgrid.Index) -> Patch:
    longitude, latitude = hexgrid.geo_coordinates(index)
    data = get_data(longitude, latitude)
    resources = (
        density(**data) *             # Carrying capacity per kmÂ²
        hexgrid.AREA *                # Area in kmÂ²
        time_step_energy_use   # Individual energy needs
    )
    return Patch(resources, resources)


@dataclass(frozen=True)
class ParameterSetting:
    n_steps: halfyears = 30_000
    # The number of half-year steps to run the simulation for. The default is
    # 30000 half-years, because the current scientific consensus is that the
    # settlement of the Americas began some 15000 years BP.
    daily_energy: kcal = 2263
    # Energy consumption per adult per day. According to Pontzer et al. (2012),
    # the mean daily total energy expenditure among Hadza was 2263 kcal (mean
    # of men and women). Smith & Smith (2003) work with a staple diet
    # containing 2390 kcal/day.
    payoff_standarddeviation: float = 0.1
    # The standard deviation of the foraging contribution distribution,
    # relative to the expected foraging contribution of an individual.
    cooperation_gain: float = 0.5
    # The exponent of the additional efficiency of a group working together.
    # If, eg., cooperation_gain==0.3, then two individuals working together
    # contribute as much as 4 working separately, 3 as 7.2, 4 as 11, 5 as 15
    # etc.
    storage_loss: float = 0.33
    # The proportion of stored resources lost per time step to various random
    # effects, such as pests, rot, spoilage, or leaving them behind when
    # migrating. Morgan (2012) pulls a number of 33%% per year (focussing on
    # the winter season when it matters) out of thin air.
    culture_mutation_rate: float = 6e-2
    # The probability per half-year that one aspect of culture changes
    cooperation_threshold: float = 6
    # The minimum cultural distance where cooperation breaks down
    area: float = 450_000_000
    # Design area of the hex grid
    attention_probability: float = 0.1
    # Probability to know about the state of some patch
    resource_recovery: float = 0.2
    # The growth rate of a path's resources over half a year
    evidence_needed: float = 0.3
    # The proportion of seasonal payoff that needs to be more somewhere else
    # for the family to move. Crema (2015) has c=3 for Î¼=10, so we take 0.3 as
    # the default.
    accessible_resources: float = 0.3
    # The proportion of resources that are accessible to foraging. cf. Crema
    # (2015)
    culture_dimensionality: int = 20
    # The number binary dimensions of 'Culture'


params: ParameterSetting
time_step_energy_use: kcal
similar_culture: Callable[[cython.int, cython.int], bool]


def set_params(new_params: ParameterSetting) -> None:
    """Set new parameter settings and derived objects."""
    global params
    global time_step_energy_use
    global similar_culture

    params = new_params
    time_step_energy_use = params.daily_energy * 365.24219 / 2
    if params.cooperation_threshold == 6:
        from dispersal_model.similar_culture_benchmark import similar_culture
    else:
        def similar_culture(c1: cython.int, c2: cython.int) -> bool:
            return cultural_distance(c1, c2) < params.cooperation_threshold


set_params(ParameterSetting())


def initialization() -> State:
    start1 = hexgrid.closest_grid_point(-159.873, 65.613)
    # Western Tip of Alaska
    start2 = hexgrid.closest_grid_point(-158.2718, 60.8071)
    # SW Alaska

    return State(
        patches=OnDemandDict(patch_from_grid_index),
        # In the program, patches are only created when a family actually needs
        # to inspect them. Because they are static and not influenced by the
        # simulation when no families are around this does not matter.
        families=DefaultDict[hexgrid.Index, List[Family]](
            list, {
                start1: [Family(
                    descendence="F",
                    culture=0b000_000_000_000_000,
                    location_history=[start1],
                    stored_resources=16000000)],
                start2: [Family(
                    descendence="A",
                    culture=0b111_111_111_111_111,
                    location_history=[start2],
                    stored_resources=16000000)],
            }),
        t=0)


# # 6. Input Data
#
# This model does not currently use input data to represent time-varying
# processes. At a later stage, the inclusion of paleoclimate data for the
# Americas is intended as input data.
#
# # 7. Submodels
#
# The model has various sub-modules, which are taken from the existing
# literature with adaptations to make them all fit together. They are listed
# here in the same order as their appearance in [Section
# 3](#3.-Process-overview-and-scheduling)
#
# ## 7.1 Resource use
def use_resources_and_maybe_shrink(family: Family) -> None:
    """Use up a family's resources.

    A family uses their stored resources to feed as many members as possible.
    If the stored resources are insufficient to feed everyone, the family
    shrinks.

    Internally, this function modifies the Family object.

    """
    resources, size = family.stored_resources, family.effective_size
    while resources_at_season_end(resources, size) < 0 and size > 0:
        size -= 1
        family.seasons_till_next_child = max(family.seasons_till_next_child, 2)
    family.effective_size = size
    family.stored_resources = resources_at_season_end(
        family.stored_resources, family.effective_size)


def resources_at_season_end(resources: kcal, size: int) -> kcal:
    """Check a family's resources at the end of the season.

    Compute how many resources a family of given size would have at the end of
    a half-year time step, given the amount at the beginning of the half year.
    Every adult consumes the same fixed amount of resources.
    If the remainder is negative, some of the individuals in the family starve.

    >>> params.storage_loss
    0.33
    >>> resources_at_season_end(100, 0)
    67.0

    """
    resources_after = resources - (
        size * time_step_energy_use)
    if resources_after > 0:
        resources_after *= (1 - params.storage_loss)
    return resources_after


def is_moribund(family: Family) -> bool:
    """A family of less than 2 individuals is not a family any more.

    It gets marked for deletion from the simulation state.

    """
    if family.effective_size < 2:
        return True
    else:
        return False


# ## 7.2 Population growth
def maybe_grow(family: Family) -> None:
    """Grow the family, if that's what should happen.

    Families grow unconditionally after a fixed waiting time, starting after
    their last child or after the last season in which they suffered from lack
    of resources. If resources are plenty, families will have children every 2
    seasons, i.e. every one year.

    """
    if family.seasons_till_next_child <= 0:
        family.effective_size += 1
        family.seasons_till_next_child = 2
    else:
        family.seasons_till_next_child -= 1


# ## 7.3 Creation of new agents
def maybe_procreate(family: Family) -> Optional[Family]:
    """Split a family in two when conditions are right.

    Agents procreate when they contain 10 or more adult individuals. On the
    level of the individuals forming the family, this means that two
    individuals split off to form a new family. There is some bookkeeping
    involed to generate meaningful `descendence` values for the analysis, when
    we might want to track how genetic relationships, culture and geography
    interact.

    The offspring family inherits (a copy of) the parent family's location
    history and culture and can expect their first child to be an adult
    contributor after 12 years.

    """
    if family.effective_size < 10:
        return None
    else:
        family.number_offspring += 1
        family.effective_size -= 2
        # These two individuals form the new family
        return Family(
            effective_size=2,
            descendence="{:s}:{:d}".format(
                family.descendence, family.number_offspring),
            location_history=family.location_history[:],
            seasons_till_next_child=halfyears(12 * 2),
            # If these two get a child now, it may count as adult in maybe 12
            # years.
            culture=family.culture)


# ## 7.4 Migration
def decide_on_moving(
        family: Family,
        current_patch: Patch,
        known_destinations: Iterator[Tuple[hexgrid.Index, Patch, int, int]],
        avoid_stay: bool = False) -> hexgrid.Index:
    """Decide on the next location for a family to move to.

    A family has knowledge about their current location (which is only used to
    check that the known destinations are working in the correct order) and
    some nearby locations, represented by `known_destination`. This function
    picks one of those nearby locations for the family to move to.

    If the `avoid_stay` switch is set to `True`, the decision is heavily biased
    against staying in the same location.

    The target location is the best location the family knows about if that
    location can support at least one more person than the current location.
    If the best location is not significantly better
    (in that sense) than the current location,
    stay unless staying is to be avoided.
    If multiple locations are equally promising, choose one at random.

    """
    try:
        target, patch, cooperators, competitors = next(known_destinations)
    except StopIteration:
        return family.location
    assert patch == current_patch
    if avoid_stay:
        try:
            target, patch, cooperators, competitors = next(known_destinations)
            cooperators += family.effective_size
        except StopIteration:
            # There really is no other place to go to.
            pass

    max_gain: kcal = resources_from_patch(
        patch, cooperators, competitors, estimate=True
    ) * family.effective_size / cooperators
    current_gain = 0 if avoid_stay else max_gain
    c = 0
    # c is a counting variable to help deal with equal expected gains without
    # bias in favour of those items earlier in the list, and while avoiding to
    # shuffle the entire list.
    for coords, patch, cooperators, competitors in known_destinations:
        expected_gain = resources_from_patch(
            patch,
            family.effective_size + cooperators, competitors,
            estimate=True) * (
                family.effective_size / (family.effective_size + cooperators))
        if expected_gain >= max_gain:
            if expected_gain < (
                    current_gain +
                    time_step_energy_use * params.evidence_needed):
                continue
            if expected_gain == max_gain:
                c += 1
                if random.random() < c / (1 + c):
                    continue
            target = coords
            max_gain = expected_gain
    return target


def test_decide_on_moving_is_unbiased() -> Counter[hexgrid.Index]:
    """Check the bias of the 'decide on moving' submodule.

    The implementation of the equal random choice in that module is
    not very transparent, and should therefore be checked.

    Run generate 20 equally promising neighbors and run the function
    `decide_on_moving` on them 10000 times. If that function is unbiased (as I
    assert) and does not favor neighbors passed earlier or later in the
    iterator of neighbors it gets passed, then the count of destination indices
    should be roughly evenly distributed between all the 20 different indices.

    """
    family = Family(descendence='', culture=0, effective_size=1)
    current_patch = Patch(resources=1, max_resources=2)
    known_destinations = [('', current_patch, 2, 0)] + [
        (str(i),
         Patch(resources=2 + 3 * time_step_energy_use,
               max_resources=2 + 3 * time_step_energy_use),
         2,
         0)
        for i in range(20)]
    c: Counter[hexgrid.Index] = Counter()
    for i in range(100000):
        d = decide_on_moving(
            family, current_patch, iter(known_destinations))
        c[d] += 1

    for key, value in c.items():
        assert 4000 < value < 6000
    return c


def movement_bookkeeping(
        family: Family, destination: hexgrid.Index, state: State) -> None:
    """Remove family from its old location in state and add it to the new one.

    There is some bookkeeping to be done, because we want every location
    to appear only once in the family's movement history, and the
    bidirectional link from the grid stored in the state to the family
    and from the family to its grid location needs to be maintained.
    """
    if destination == family.location:
        return
    try:
        family.location_history.remove(destination)
    except ValueError:
        pass
    try:
        state.families[family.location].remove(family)
    except ValueError:
        pass
    family.location_history.insert(0, destination)
    state.families[family.location].append(family)


# ## 7.5 Cooperative Resource Extraction
def extract_resources(
        patch: Patch, group: List[Family], total_labor_here: int) -> kcal:
    """Distribute the resources gained from cooperative extraction.

    Distribute the resources gained from cooperative extraction proportionally
    to the contributed labor, keep track of the amout of resources that have
    thus vanished from the patch.

    """
    labor = sum([family.effective_size
                 for family in group])
    resources_extracted = resources_from_patch(
        patch, labor, total_labor_here - labor)
    for family in group:
        family.stored_resources += (
            resources_extracted * family.effective_size / labor)
    return resources_extracted


def resources_from_patch(
        patch: Patch,
        labor: int,
        others_labor: int,
        estimate: bool = False) -> kcal:
    """Compute or estimate the resources a cooperative gains from a patch.

    Compute the total resources that a cooperative of aggregated size `labor`,
    competing with `other_labor` individuals in the same patch, extracts from
    that patch.

    In the actual extraction step, this includes a random component. When a
    family uses this function to estimate the payoff from a patch under
    consideration, they get the expectation of the random distribution without
    randomness.

    The structure follows Crema (2014).

    """
    my_relative_returns = (
        time_step_energy_use * labor *
        effective_labor_through_cooperation(labor))
    if not estimate:
        my_relative_returns = max(
            random.gauss(
                mu=my_relative_returns,
                sigma=(params.payoff_standarddeviation *
                       time_step_energy_use / labor ** 0.5)),
            0)
    if others_labor:
        others_relative_returns = (
            time_step_energy_use * others_labor *
            effective_labor_through_cooperation(others_labor))
        if not estimate:
            others_relative_returns = max(
                random.gauss(
                    mu=others_relative_returns,
                    sigma=(params.payoff_standarddeviation *
                           time_step_energy_use / others_labor ** 0.5)),
                0)
        # If two groups compete, each can under-estimate the relative returns
        # of the other one. In that case, there is a chance to exploit more
        # resources than would be normally accessible. FIXME: There is
        # potentially a way out, which also gets rid of the `estimate` optional
        # argument and reduces the number of random draws. The calling function
        # could do the random draw, and keep track of the deviations locally,
        # passing adjusted labor values to here. This may be worth
        # implementing.
    else:
        others_relative_returns = 0
    return (my_relative_returns) / (
        my_relative_returns + others_relative_returns) * min(
            my_relative_returns + others_relative_returns,
            patch.resources * params.accessible_resources)


def effective_labor_through_cooperation(n_cooperators: int) -> float:
    """Effective labor contribution of a group of cooperators.

    A single human can forage a certain amount, but by the assumptions of the
    model, two cooperating foragers gain more resources together than they
    would individually. The effective labor returned by this function is the
    factor by which 2 cooperating foragers are better than 2 separate foragers.

    This formula follows Crema (2014), with the caveat that Crema computes
    payoffs, whereas we compute a multiplicative factor (effective labor) which
    is multiplied with the standard resource gain to give the acutal resource
    payoffs. Given that Crema's payoffs have a mean of Î¼=10, we adjust our
    effective labor by the opposite factor.

    """
    return (1 + (n_cooperators - 1) ** params.cooperation_gain / 10)
# In formulas, that the effective labor $k$ for a group of size $l$ is $k(l) =
# 1 + \frac{(l - 1)^{c}}{10}$. In plots, this looks as follows.


def test_effective_labor() -> None:
    """Check and plot the effective labor computation.

    We have some expectations concerning the shape of effective labor from
    labor for the default parameter $c=0.5$, which are tested here.

    """
    assert 2 < 2 * effective_labor_through_cooperation(2) < 3
    assert 12 < 10 * effective_labor_through_cooperation(10) < 20
    assert 150 < 100 * effective_labor_through_cooperation(100) < 200
    plt.title("Effective labor depending on group size")
    plt.plot(numpy.arange(1, 100),
             numpy.arange(1, 100) *
             effective_labor_through_cooperation(numpy.arange(1, 100)))


def adjust_culture(cooperating_families: List[Family]) -> None:
    """Equalize the cultures of families that cooperated."""
    n = len(cooperating_families)
    for family in cooperating_families:
        mutate_culture(family)
    if n <= 1:
        return

    target = cooperating_families[
        random.randrange(len(cooperating_families))].culture
    for family in cooperating_families:
        family.culture = target


def mutate_culture(family: Family) -> None:
    """Change the culture of a family according to a small mutation rate.

    In practice, to avoid random draws (which are computationally expensive),
    draw a geometric distribution for the time until the next mutation happens
    and count down towards it.

    """
    if family.seasons_till_next_mutation:
        family.seasons_till_next_mutation -= 1
    else:
        if family.seasons_till_next_mutation == 8 or (
                family.seasons_till_next_mutation is None and
                random.random() < params.culture_mutation_rate):
            i = random.randrange(params.culture_dimensionality)
            family.culture ^= 1 << i
        family.seasons_till_next_mutation = numpy.random.geometric(
            params.culture_mutation_rate)


def exploit(patch: Patch, resource_reduction: kcal) -> None:
    """Adjust a patch's resources according to current expoitation."""
    patch.resources -= resource_reduction
    # Patch resources should always be bigger than 0, because of
    # `params.accessible_resources` < 1. Any deviations would be to very weird
    # float rounding issues. Negative resources are really problematic, because
    # the patch can never recover from them (in fact, it gets worse and worse),
    # so raising an exception in that case is useful.
    assert patch.resources > 0


# ## 7.6 Patch Resource Dynamics
def recover(patch: Patch) -> None:
    """The resources of a patch recover following a logistic function."""
    if patch.resources < patch.max_resources - 1:
        patch.resources += (
            patch.resources *
            params.resource_recovery *
            (1 - patch.resources / patch.max_resources))


sources = """
# Bibliography

Grimm, Volker & Berger, Uta & Bastiansen, Finn & Eliassen, Sigrunn & Ginot,
    Vincent & Giske, Jarl & Goss-Custard, John et al. 2006. A standard protocol
    for describing individual-based and agent-based models. Ecological
    Modelling 198(1). 115â€“126. (doi:10.1016/j.ecolmodel.2006.04.023)

Grimm, Volker & Berger, Uta & DeAngelis, Donald L. & Polhill, J. Gary & Giske,
    Jarl & Railsback, Steven F. 2010. The ODD protocol: A review and first
    update. Ecological Modelling 221(23). 2760â€“2768.
    (doi:10.1016/j.ecolmodel.2010.08.019)

Fick, S.E. & Hijmans, R.J. 2017. WorldClim 2: new 1km spatial resolution
    climate surfaces for global land areas. International Journal of
    Climatology 37 (12): 4302-4315.
    (https://worldclim.org/data/worldclim21.html)

""".split("\n\n")[1:]
